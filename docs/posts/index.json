[
    
        
            {
                "ref": "https://www.if-blog.site/posts/hugo/hugo-related-posts/",
                "title": "Hugoの記事に関連記事を表示させる",
                "section": "posts",
                "date" : "2021-07-18",
                "body": "記事の最後に関連記事を表示する方法が簡単になってた。\nhttps://gohugo.io/content-management/related/\nこれで関連記事を取れる\n.Site.RegularPages.Related 以下のような感じで記事の最後につけるとおｋ\n{{ $related := .Site.RegularPages.Related . | first 5 }} {{ with $related }} \u0026lt;h3\u0026gt;See Also\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{ range . }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; {{ end }} 関連記事の設定も少しできるみたい。\n[related] includeNewer = false threshold = 80 toLower = false [[related.indices]] name = \u0026#34;keywords\u0026#34; weight = 100 [[related.indices]] name = \u0026#34;date\u0026#34; weight = 10 設定はそれぞれ、\n  threshold\nしきい値。0-100の値。低くするとよりマッチするけど、あんまり関連性無くなる\n  includeNewer\n現在の記事より新しい記事を含めるかどうか。新しい記事を追加すると関連記事一覧も変わる。\n  toLower\nindexesとクエリに小文字を含めるかどうか。より正確な関連記事が出る場合もある。\n  "
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/python/open-ai-gym-quick/",
                "title": "Open AI Gymをとりあえず動かす",
                "section": "posts",
                "date" : "2021-07-14",
                "body": "Open AI Gymのquick startです。とりあえず動かしてみます。\ndocument\nhttps://gym.openai.com/docs/\nInstall pip install gym Run import gym env = gym.make(\u0026#39;CartPole-v0\u0026#39;) env.reset() for _ in range(1000): env.render() env.step(env.action_space.sample()) # take a random action env.close()  gym.make()で環境を選択 env.reset()で環境を初期化 env.render()で描画 env.action_space.sample()が行動。今回はランダム env.step()で行動を引数にして状態遷移  今回は環境にCartPoleを選択。Cartの上でPoleを倒さないように動くやつ。\n環境はClassic controlだと特に描画の設定などせずに使えたはず。\n用意されてる環境はここ\nhttps://gym.openai.com/envs/#classic_control\nCartPoleで環境に対して取れる行動は、左に動く、動かない、右に動くの三種類。\nCartPoleでの環境から得られる情報は、potisionとvelocity\nそれぞれgithubを参照\nhttps://github.com/openai/gym/wiki/MountainCar-v0#actions\ncustome env 環境を作成できる\nhttps://github.com/openai/gym/blob/master/docs/creating-environments.md\n環境用にディレクトリを作成\ngym-foo/ README.md setup.py gym_foo/ __init__.py envs/ __init__.py foo_env.py foo_extrahard_env.py setup.pyと__init__.pyを環境に合わせて書いておく。\ngithubのドキュメント通り。\nEnvを継承して、いろいろと実装する。\nimport gym from gym import error, spaces, utils from gym.utils import seeding class FooEnv(gym.Env): metadata = {\u0026#39;render.modes\u0026#39;: [\u0026#39;human\u0026#39;]} def __init__(self): ... def step(self, action): ... def reset(self): ... def render(self, mode=\u0026#39;human\u0026#39;): ... def close(self): ... インストールすると、\npip install -e gym-foo Cartpoleみたいに呼び出せる\ngym.make('gym_foo:foo-v0') gym.envs.classic_control.rendering以下にclassic_controlで使ってる便利なのが入ってるので参考になりそう。\nfrom gym.envs.classic_control import rendering self.viewer = rendering.Viewer(screen_width, screen_height) circle = rendering.make_circle() "
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/nlp/end-to-end_text_classification_via_image-based_embedding_using_character-level_networks/",
                "title": "End-to-End Text Classification via Image-basedEmbedding using Character-level Networks",
                "section": "posts",
                "date" : "2020-12-30",
                "body": " 日本語、中国語、タイ語など、形態素解析に基づく単語境界を持たない言語の分析や理解のためには、単語の埋め込みの前に適切な単語分割を行うことが望まれるが、これらの言語では本質的に困難である。しかし、これらの言語では、それは本質的に困難である。近年、ディープラーニングに基づく様々な言語モデルの進歩は目覚ましく、文字レベルの特徴量を利用した手法の中には、このような困難な問題を回避することに成功しているものもある。しかし，上記の言語の文字レベル特徴量をモデルに与えると，文字種の数が多いためにオーバーフィッティングが発生することが多い．本論文では，これらの問題を解決するために，文字エンコーダを用いた文字レベル畳み込みニューラルネットワークであるCE-CLCNNを提案する．提案するCE-CLCNNは、エンドツーエンド学習モデルであり、画像ベースの文字エンコーダー、すなわち、対象文書中の各文字を画像として扱う。様々な実験を行った結果，提案するCE-CLCNNは，視覚的にも意味的にも類似した文字に対しても密接に埋め込まれた特徴を捉えることができ，いくつかのオープン文書の分類タスクにおいて最先端の結果を達成することを確認した．本論文では、Wikipediaのタイトル推定タスクを用いたCE-CLCNNの性能を報告し、内部挙動を分析した。\n www.DeepL.com/Translator（無料版）で翻訳しました。\nII. CE-CLCNN CE-CLNCCは、2つの異なるCNNからなる。\n１つ目のCNNは、文字画像を入力としcharacter encoderとして振る舞う。 ２つ目のCNNは、document classificationに用いられる。\nA. Character encoder by CNN 入力文字列を36×36 pixelの画像に変換する。\nLayer # CE configuration 1 Conv(k=(3, 3), o=32) → ReLU 2 Maxpool(k=(2, 2)) 3 Conv(k=(3, 3), o=32) → ReLU 4 Maxpool(k=(2, 2)) 5 Conv(k=(3, 3), o=32) → ReLU 6 Linear(800, 128) → ReLU 7 Linear(128, 128) → ReLU B. Document classifier by CLCNN Layer # CLCNN configuration 1 Conv(k=(1, 3), o=512, s=3) → ReLU 2 Conv(k=(1, 3), o=512, s=3) → ReLU 3 Conv(k=(1, 3), o=512) → ReLU 4 Conv(k=(1, 3), o=512) 5 Linear(5120, 1024) 6 Linear(1024, # classes) データセット Wikipediaタイトルデータセットを使う。 これには、以下の12個のラベルが含まれており、これを文章分類のラベルに使う。\nGeography, Sports, Arts, Military, Economics, Transportation, Health Science, Education, Food Culture, Religion and Belief, Agriculture and Electronics.\nAnalysis of Character Encoder cnn encoderを用いて文字の特徴量を抽出した。特徴量は、意味が類似している文字ごとに近い値となった。 形状特徴を明示的にを学習させたわけではなく、文章分類タスクを行うことが原因と考えられる。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/nlp/enhanced-character-embedding-for-chinese-named-entity-recognition/",
                "title": "Enhanced character embedding for Chinese named entity recognition",
                "section": "posts",
                "date" : "2020-12-30",
                "body": "Enhanced character embedding for Chinese named entity recognition https://journals.sagepub.com/doi/pdf/10.1177/0020294020952456\n 従来の名前付き実体認識方法では、主に手作業による特徴の応用を模索しています。現在では、ディープラーニングの普及に伴い、名前付き実体認識のための深い特徴を捕捉するためにニューラルネットワークが導入されている。しかし、既存の手法の多くは、現代のコーパスを対象としたものに限られている。古文献の名前付き実体認識は、名前が時間の経過とともに進化してきたために困難である。本論文では、文字や筆跡の特徴を探ることで実体認識を試みる。トランスフォーマーとストロークからの双方向エンコーダ表現に基づいて、ECEMと名付けられた拡張文字埋め込みモデルを提案する。第一に、ECEMは単語の文脈に応じて動的に意味ベクトルを生成することができる。第二に、提案するアルゴリズムは、中国語の単語の形態素レベルの情報を導入する。最後に、強化された文字埋め込みは、学習のために双方向性の長期短期記憶条件付きランダムフィールドモデルに供給される。提案したアルゴリズムの効果を調べるために，実験 を古文と現代文の両方のコーパスで実施した．その結果，我々のアルゴリズムが非常に有効であることがわかった．従来のものと比較して、強力である。\n The proposed recognition algorithm 提案アルゴリズムであるECEMでは、前処理、embedding、BiLSTM Layer、CRF Layerの４つのコンポーネントからなる。\nembeddingでは、cw2vecとBERTを用いる。 NERには、BIO schemeを用いる。\nData pre-processing 固有表現抽出/the named entity recognition (NER)\nEnhanced character embedding BERT BiLSTM layer CRF layer input sequence: X = (x_1, x_2, ... x_n)\npredictin sequence: y = (y_1, y_2, ... y_n)\nthe equence yの確率は、softmaxを使って計算される。\np(y | X) softmax(e^f(X, y)) ここで、f(X,y)は、以下の用に計算される。\nf(X,y)= ただし、PはBiLSTMの出力した行列である。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/android/bottom-sheet/",
                "title": "Bottom Sheetをつける",
                "section": "posts",
                "date" : "2020-03-01",
                "body": "Google Mapで下から引っ張ると出てくるやつ。\n調べたら以外と簡単にできた。\ndependenciesを追加。\ndependencies { implementation 'com.google.android.material:material:1.0.0' } 例\n\u0026lt;androidx.coordinatorlayout.widget.CoordinatorLayout ..... \u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;@+id/bottomSheetLayout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; app:behavior_hideable=\u0026#34;false\u0026#34; app:behavior_peekHeight=\u0026#34;56dp\u0026#34; app:layout_behavior=\u0026#34;@string/bottom_sheet_behavior\u0026#34;\u0026gt; 中身 \u0026lt;/LinearLayout\u0026gt; \u0026lt;/androidx.coordinatorlayout.widget.CoordinatorLayout\u0026gt; bottm sheetにしたいコンテンツ、今回の例ではLinearLayout、のlayout_behaviorを以下のように指定。\napp:layout_behavior=\u0026quot;@string/bottom_sheet_behavior\nCoordinatorLayoutの一番下に配置する。\n開いたり閉じたりをコードで制御する場合は、activity/fragmentの中で以下のように設定する。\nbottomSheetBehavior = BottomSheetBehavior.from(bottomSheetLayout) // 隠す bottomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED // 開く bottomSheetBehavior.state = BottomSheetBehavior.STATE_EXPANDED コールバックも設定できる。\nbottomSheetBehavior.setBottomSheetCallback(object: BottomSheetBehavior.BottomSheetCallback(){ override fun onSlide(p0: View, p1: Float) { TODO(\u0026#34;not implemented\u0026#34;) //To change body of created functions use File | Settings | File Templates.  } override fun onStateChanged(p0: View, p1: Int) { TODO(\u0026#34;not implemented\u0026#34;) //To change body of created functions use File | Settings | File Templates.  } }) 参考\nhttps://blog.mindorks.com/android-bottomsheet-in-kotlin\nhttps://qiita.com/fumiyakawauso/items/1d0fa27aa508a3e0570a\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/android/android-introduction/",
                "title": "Webアプリケーションしか作ったことがない人がAndroidの開発を始めたときの情報収集の流れ",
                "section": "posts",
                "date" : "2020-02-28",
                "body": "これまでフロントエンド/バックエンドしか作ったことなく、ようやくAndroid開発に入門したのだが、\n始めのころの情報収集が意外と大変だったので、同じような境遇の人の為にまとめておく。\n上からみていくと、フロントエンド/バックエンドしか開発したことがなくても、流れが掴みやすいかと\nライブラリ Android 9.0(API 28)以降では、Android Xというライブラリを使っていく。\nAndroid Xは、Android Jetpackという、ライブラリ群の1部らしい。\nAndroid Jetpackとは、\n Jetpack は、高品質の Android アプリをデベロッパーが簡単に作成するための一連のライブラリ、ツール、およびガイダンスです。\n https://developer.android.com/jetpack?hl=ja\nJetpackについては、以下の記事が参考になった。\nhttps://qiita.com/k_masa777/items/c01c1de6ac763ce5c075\n検索する際には、古いライブラリの記事が結構出てくるので、Android Xかどうか注意\nアーキテクチャ MVCやクリーンアーキテクチャなどのアーキテクチャがAndroidでも存在する。\nModel-View-ViewModelで構成されるMVVMという構成が主流っぽい\nView: 画面表示\nViewModel: Modelから値を取得、Viewに表示する値を管理\nModel: データモデル、ビジネスロジック\nここでのモデルは、DDDのモデルよりも少し多機能な感じ\nアーキテクチャを一通り紹介していてわかりやすかった。\nhttps://employment.en-japan.com/engineerhub/entry/2018/01/17/110000\nMVVMの実装する上でわかりやすかった\nhttps://qiita.com/Tsutou/items/69a28ebbd69b69e51703\nコードサンプル MVVM意外にもクリーンアーキテクチャなど、様々なサンプルがあってわかりやすい\nhttps://github.com/android/architecture-samples\nhttps://github.com/android10/Android-CleanArchitecture-Kotlin\nロジック Androidでは、APIを叩く、画面表示する、ホスト(Android端末)のリソースを管理するなど、やることが多い。\nまずは、Webアプリケーションにおける、バックエンドに当たる部分について、まとめる。\nHTTP Request http clientは、retrofitというライブラリがよく使われてる様子\nhttps://square.github.io/retrofit/\n参考\nhttps://qiita.com/SYABU555/items/3b280a8e81d2cc897383\n非同期処理 APIは非同期で実行したい。Androidでは、UIスレッドと呼ばれる、スレッドがメインスレッドとして動作する。\nUIの描画など、UIスレッドで実行しなければならないものがある。\n別スレッドを起動することも可能だが、非同期処理を行いたい場合は、コルーチンを使うのが主流。\nコルーチンは、スレッドを作るより軽量で、中断可能な処理を行えるもの。\n調べると色々出てくるが、使い方については、以下が参考になった。\nhttps://kotlinlang.org/docs/reference/coroutines/basics.html\nhttps://qiita.com/kawmra/items/ee4acb7db61f70dec9a8\nResult APIのresponseを受け取る際には、成功/失敗をいい感じにハンドリングしたい。\nkotlinでは、Success/Failureの2つの型を持てるResult型が存在する。\nhttps://satoshun.github.io/2018/12/result/\nhttps://qiita.com/kencharos/items/6fd0a9e92363b08c0340\n使ったことないけど、Eitherも使えるライブラリもある\nhttps://arrow-kt.io/\nDB Androidでは、SQLiteが使えます。APIをキャッシュするような使い方も可能です。\nAndroid JetpackにRoomというライブラリがあるので、それを使います。\n単純な使い方はググればいくらでも出てくるので、それ以外の通常の開発に必要なものを羅列します。\nオブジェクト間のリレーションを定義する\nhttps://developer.android.com/training/data-storage/room/relationships?hl=ja\nRoomで1対多を実現する\nhttps://medium.com/@star_zero/room%E3%81%A71%E5%AF%BE%E5%A4%9A%E3%82%92%E5%AE%9F%E7%8F%BE%E3%81%99%E3%82%8B-fa27615345ba\n型コンバーターを使用する\nhttps://developer.android.com/training/data-storage/room/referencing-data?hl=ja#type-converters\n特定の列をインデックスに登録する\nhttps://developer.android.com/training/data-storage/room/defining-data?hl=ja#column-indexing\nAndroidに保存した、データをみたいとき Android Studioの(通常)右下にあるDevice File Explorerを選択。\nエミュレーター内のファイルを見ることができるので、data/ data/“package_name”/databases にある\n以下のファイル群を保存。\ndatabase_name database_name-shm database_name-wal SQLite用のクライアントを使って中身を確認することができる。\nクライアント\nhttps://sqlitebrowser.org/dl/\nUI Androidでは、基本的に、Activieにロジックを記述し、Activityとxmlで記述されたlayoutが1対1で対応し1つの画面を構成する。\nこれでは、Activityが肥大化してしまうので、MVVMでは、1つのActivityに複数の画面(Fragment)を持たせる。\nAcitivtyでは画面の構成、Fragmentでは各画面のロジックのみを持つ。\nまた、Fragmentは、 コンポーネントの用に複数のFragmentを用いて、1つの画面を構成するという使い方もできる。\nactivityとfragmentはそれぞれ異なるライフサイクルを持ち、\n例えば、画面の回転や、List表示する為のデータの保持などの場合に考慮する必要がある。\nactivityのライフサイクル https://developer.android.com/guide/components/activities/activity-lifecycle?hl=ja#alc\nfragmentのライフサイクル https://developer.android.com/guide/components/fragments?hl=ja#Creating\nLayout コンポーネントを単純に縦横に並べるだけなら、LinearLayoutで良い。\n細かく指定したい場合は、ConstraintLayoutが便利。\n位置の指定の仕方に始めは、戸惑うが以下がわかれば簡単。\napp:layout_constraint[自分の辺]_to[相手の辺]Of=\u0026quot;@+id/相手のid\u0026quot; さらに詳しくは、以下の記事が参考になった。\n[Android] ConstraintLayout レイアウト逆引きまとめ\nhttps://qiita.com/tktktks10/items/62d85dabac4bdb8c1f94\nデータバインディング Android Jetpackの提供する、データバインディングライブラリを使う。\nWebアプリケーションでは、HTMLとロジック間でデータをバインディングしリアルタイムで表示を変えたりなどを行う。\nデータバインディングライブラリを使うことで、同様のことが実現できる。\nデータバインディング\nhttps://developer.android.com/topic/libraries/data-binding/?hl=ja\nアイコン res \u0026gt; vector \u0026gt; .... でアイコンの追加が行える。\n意外と出てこなくてハマった。\nfont-awesome使う場合 以下の記事が参考になった\nhttps://www.androidhive.info/2019/06/use-font-awesome-icons-android/\nhttps://fontawesome.com/icons?d=gallery\nアニメーション メニューのアコーディオンや、移動など単純なアニメーションは、\nres/anim/sample.xmlを配置し、実現できる。\n移動アニメーションの例\nhttps://akira-watson.com/android/translate-animation.html\nPaging リストを描画し、無限スクロールさせたい場面は多いと思う。\nViewModelとPaging library、RecyclerViewを使って実現できる。\n以下の記事が参考になった。\nAndroid Jetpack 初級 ( Paging library + LiveData + Retrofitで、簡単無限スクロール)\nhttps://qiita.com/Tsutou/items/bae47cf55292f3349284#livedata\nPaging Library + API でページング処理\nhttps://medium.com/@star_zero/paging-library-api-%E3%81%A7%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%B3%E3%82%B0%E5%87%A6%E7%90%86-5e68543e7031\nhttps://github.com/STAR-ZERO/paging-retrofit-sample\nコードサンプル\nhttps://github.com/Tsutou/PagingLiveData\nAPIを叩きつつ、DBにキャッシュする例\nhttps://medium.com/@star_zero/paging-library-api-%E3%83%87%E3%83%BC%E3%82%BF%E8%BF%BD%E5%8A%A0-%E5%89%8A%E9%99%A4-eae42d0853cb\nfirebase Authenticationやデータベースなどが簡単に使える。\nGoogleアカウントでのログインを行いたい場合など便利\nAndroid プロジェクトに Firebase を追加する\nhttps://firebase.google.com/docs/android/setup?hl=ja\nリリース https://developer.android.com/studio/publish/preparing?hl=ja\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/android/book-reports-firebase/",
                "title": "ボタン以外のコンポーネントに波紋エフェクト(ripple effect)つける",
                "section": "posts",
                "date" : "2020-02-28",
                "body": "TextViewなどのbackgroudに以下を指定すればおk\nandroid:background=\u0026quot;?attr/selectableItemBackground\u0026quot;\nbackgroundで色などをすでに指定している場合は、以下のようにする。 foregroundに指定する。\n\u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:padding=\u0026#34;0dp\u0026#34; android:background=\u0026#34;#bbffbb\u0026#34; android:foreground=\u0026#34;?android:selectableItemBackground\u0026#34; android:text=\u0026#34;Hello World!\u0026#34;/\u0026gt; "
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/edgwbs/book-storage-vue/",
                "title": "Vue.js+typescriptでVuetifyを使いマテリアルデザインに入門する",
                "section": "posts",
                "date" : "2019-11-09",
                "body": "はじめに Vuetifyは、Vue.jsで使えるマテリアルデザインのフレームワークです。\nhttps://vuetifyjs.com/ja/\nマテリアルデザインに入門すべく、Vuetifyを使って読んだ本を管理するサービスを作ってみました。\nBook Storage\n簡単にマテリアルデザインを使えるVuetifyですが、以下のような特徴があります。\n ボタンやカードなどのマテリアルデザインのコンポーネントが用意してあり、簡単に利用できる flexboxをラップしたグリッドシステムがあり、レスポンシブ対応が容易 コンポーネントとグリッドシステムを用いることで、cssを(ほとんど)書く必要がない マテリアルデザインの仕様であるフォント(Roboto Font)、アイコンが利用できる  ドキュメントが充実しており、基本的にドキュメントを見ると簡単に使えるという印象です。ドキュメントはjavascriptで書かれているため、typescriptで使う場合には、読み換える必要があります。\nサポートブラウザはドキュメントを参照\nhttps://vuetifyjs.com/ja/getting-started/quick-start#supported-browsers\n2019年7月にv2.0.0がリリースされ、旧バージョン(v1.5.0)から記法が大きく変わったので、その際に注意する点も含め紹介していきます。\nインストール vue cli 3を使うと楽ということなのでvue cliを使ってインストールします。\n$ vue --version 3.9.1 typescriptのプロジェクトを作成します.\n$ vue create my-app vuetifyを追加する.\n$ cd my-app $ vue add vuetify すると以下のような選択肢が表示される. Defaultを選択すると、ツリーシェイキングなどの機能が追加された形で追加される.\n$ ? Choose a preset: (Use arrow keys) $ \u0026gt; Default (recommended) $ Prototype (rapid development) $ Configure (advanced) ツリーシェイキングについては、こちらの記事がわかりやすかったです。\nhttps://qiita.com/genshun9/items/4a00aa6c709b9f024821\nツリーシェイキングはwebpack4から利用でき、vue cli3はwebpack4上に構築されるため、vue cli3を利用していると自動で利用できるようになります。vuetifyのバージョンは2.0.0。\npackage.json\n\u0026#34;dependencies\u0026#34;: { \u0026#34;vuetify\u0026#34;: \u0026#34;^2.0.0\u0026#34;, .. }, フォントの追加も行います。\n$ npm install @mdi/font -D vuetifyを追加すると、新たにsrc/plugins/vuetify.tsが追加されます。\nimport Vue from \u0026#39;vue\u0026#39;; import Vuetify from \u0026#39;vuetify/lib\u0026#39;; Vue.use(Vuetify); export default new Vuetify({ icons: { iconfont: \u0026#39;mdi\u0026#39;, }, }); ここで起動すると、コンパイルエラーが出ていたので、tsconfigに以下を追加すると、うまく動くようになりました。\n\u0026#34;compilerOptions\u0026#34;: { \u0026#34;types\u0026#34;: [\u0026#34;vuetify\u0026#34;], 既存のプロジェクトへの追加 yarnもしくはnpmを使いインストールします。\n$ yarn add vuetify // OR $ npm install vuetify --save 上記のsrc/plugins/vuetify.tsを新たに作成。\n詳しくはドキュメントを参考\nhttps://vuetifyjs.com/ja/getting-started/quick-start\nGrid System vuetifyを使うには、全体を\u0026lt;v-app\u0026gt;で囲みます。\nはじめに読み込まれるコンポーネントに以下のように書けば良いかと思います。\n\u0026lt;template\u0026gt; \u0026lt;v-app\u0026gt; \u0026lt;v-header\u0026gt;\u0026lt;/v-header\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;v-footer\u0026gt;\u0026lt;/v-footer\u0026gt; \u0026lt;/v-app\u0026gt; \u0026lt;/template\u0026gt; 基本的には、以下の例のようにv-container、v-row、v-colの順番で囲む形になります。旧バージョンで利用していたv-flexやv-layoutなどの記法の代わりに、v-row、v-colを使うので注意です。\n\u0026lt;template\u0026gt; \u0026lt;v-container\u0026gt; \u0026lt;v-row\u0026gt; \u0026lt;v-col cols=12\u0026gt; コンテンツ \u0026lt;/v-col\u0026gt; \u0026lt;/v-row\u0026gt; \u0026lt;/v-container\u0026gt; \u0026lt;/template\u0026gt; v-containerはコンテンツを中央揃えおよび水平方向にパディングにします。\ngridは、Bootstrapと同様、12個のgridがあります。\n\u0026lt;v-col cols=12\u0026gt; ... \u0026lt;/v-col\u0026gt; colsプロパティを使い、gridを指定します。また、スマホ、PC用など、5つのブレークポイントが用意されており、colsに加え、ブレークポイントごとにgridが設定可能です。\n\u0026lt;v-col cols=\u0026#34;12\u0026#34; lg=\u0026#34;6\u0026#34; md=\u0026#34;6\u0026#34; sm=\u0026#34;6\u0026#34;\u0026gt; ... \u0026lt;/v-col\u0026gt; 各ブレイクポイントは以下\ngridの指定でハマったポイントは、こちらの記事を参考\nhttps://qiita.com/iss-f/items/a86586de095368cdd9a3\n詳しい部分は、grid system ドキュメントを参照\nhttps://vuetifyjs.com/ja/components/grids\nコンポーネント マテリアルデザイン仕様のカードやボタンなどのコンポーネントが用意されています. 色やサイズ、アニメーションなどcssを書かずに設定ができます。 各コンポーネントが受け取れるプロパティやイベントなどは、ドキュメントに詳しく記載してあります。\nここでは、 基本的なコンポーネントをいくつか挙げていきます。\ncard マテリアルデザインでよく見るカードは以下のように作ることができます。\n\u0026lt;v-card max-width=\u0026#34;344\u0026#34; class=\u0026#34;mx-auto\u0026#34; \u0026gt; \u0026lt;v-card-title\u0026gt;I\u0026#39;m a title\u0026lt;/v-card-title\u0026gt; \u0026lt;v-card-text\u0026gt;I\u0026#39;m card text\u0026lt;/v-card-text\u0026gt; \u0026lt;v-card-actions\u0026gt; \u0026lt;v-btn text\u0026gt;Click\u0026lt;/v-btn\u0026gt; \u0026lt;/v-card-actions\u0026gt; \u0026lt;/v-card\u0026gt; v-card-title、v-card-textには、それぞれタイトル用本文用に、フォントサイズやpaddingが設定してあります。 v-card-actionには、クリックイベントなどのアクションを設定します。\nButton v-btnタグを使い、波紋の広がるアニメーションがついたボタンが作成できます。\nシンプルな例は以下の通り。\n\u0026lt;v-btn medium color=\u0026#34;warning\u0026#34; dark\u0026gt;Normal Button\u0026lt;/v-btn\u0026gt; small, medium などのプロパティでボタンサイズが指定可能です。bootstrap同様、info、primaryなどで色の指定も可能。\nまた、その他タグを使い細かい色の指定も可能です。これらのタグは、ボタン以外のコンポーネントでも使用可能です。\nその他の色は、ドキュメントを参照\nhttps://vuetifyjs.com/ja/styles/colors\noutlined button 色抜きのボタンにする場合には、outlinedプロパティを使います。\n\u0026lt;v-btn medium color=\u0026#34;warning\u0026#34; dark outlined\u0026gt;Normal Button\u0026lt;/v-btn\u0026gt; v2.0.0からoutlinedとなり、outlineプロパティは廃止されたので注意です。\nfloating button fabプロパティを追加することで、フローティングボタンを作成することができます。\n\u0026lt;v-btn fab dark color=\u0026#34;indigo\u0026#34;\u0026gt; \u0026lt;v-icon dark\u0026gt;mdi-plus\u0026lt;/v-icon\u0026gt; \u0026lt;/v-btn\u0026gt; loading button loadingプロパティにboolean値を設定することで、trueの場合にローディングアニメーションが現れるようにすることもできます。\n\u0026lt;v-btn :loading=\u0026#34;loading\u0026#34; medium color=\u0026#34;warning\u0026#34; dark \u0026gt; Loading Button \u0026lt;/v-btn\u0026gt; その他の設定は、ドキュメントを参照\nhttps://vuetifyjs.com/ja/components/buttons\nPagination \u0026lt;v-pagination v-model=\u0026#34;page\u0026#34; :length=\u0026#34;15\u0026#34; :total-visible=\u0026#34;7\u0026#34; @input=\u0026#34;paginate()\u0026#34; \u0026gt;\u0026lt;/v-pagination\u0026gt; v-modelに現在のページ番号を設定します。lengthプロパティは全ページ数、total-visibleで表示するページングボタンの数を指定。クリックイベントで、ページングボタン押下時の挙動を設定して使うことが多いかと思います。\nまとめ Vue.jsのマテリアルデザインのフレームワークである、Vuetifyを使ってサービスを作って見ました。簡単にマテリアルデザインに入門できて、おすすめです。\nここで紹介した以外にも便利なコンポーネントが多数用意してあるのでドキュメント読んでみてください。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/gatsby/gatsby-intro/",
                "title": "技術ブログ用にGatsbyを整える",
                "section": "posts",
                "date" : "2019-10-14",
                "body": "これまでHugoを使っていたが、gatsbyを使ってみようと思います。 https://www.gatsbyjs.org/\ngatsbyは、react製の静的サイトジェネレーターです。PWAやOGPなどがあらかじめ設定してあり(themeによる？)便利です。また、記事などの任意のデータ取得のためのインターフェスとしてGraphQLを使用しているのが特徴です。(GraphQLは別途用意する必要はなく、gatsbyのbuild時に作成されます。)\nGraphQL Concepts\n静的サイトジェネレーター一覧はここがすごいわかりやすかった\nhttps://www.staticgen.com/\ngatsbyを選んだのは、reactに入門したかったのと、Hugoのテーマがスマホ対応していなかったので手を加えたかったということでタイミングがよかったからです。\n以下に、今回使ったものを備忘録として残しておきます。\nここにあげるもの一通り導入し、デザインを入れれば、基本的な技術ブログが作れるかと思います。\ntheme 今回は、テーマに変更を加える形で作ります。\nテーマは以下から選びます。 https://www.gatsbyjs.org/starters/?v=2\n以下のコマンドでテーマ入った状態で、gatsbyのプロジェクトが生成されます。\n$ gatsby new gatsby-starter-default\nhttps://github.com/gatsbyjs/gatsby-starter-default\ngatsbyのチュートリアルに目を通しつつ、themeに手を加えていきます。\nMarkdownで記事を書く 以下のページを参考にしました。\nhttps://www.gatsbyjs.org/docs/adding-markdown-pages/\nある程度試して使い方がわかれば、markdownに対応したthemeがあるので、そちらを使った方が楽かと思います。\n以下のようなqueryで一覧が取得できます。\n{ allMarkdownRemark { edges { node { html headings { depth value } frontmatter { # Assumes you're using title in your frontmatter. title } } } } } 日付順にソート、limit、skipを与えることで、ページング処理もできます。\n allMarkdownRemark( sort: { fields: [frontmatter___date], order: DESC } limit: $limit skip: $skip ) { . . icons 以下のものがすぐに使えてよかったです。\nhttps://react-icons.netlify.com/#/\n(emacsがないのが解せぬ…)\nコードのハイライト 技術ブログなので、コードのハイライトは必須です。Gatsbyで使えるものがいくつかあるようですが、自分の使う言語に対応していたので以下を使いました。\nPrism: https://prismjs.com/\nPrismを使ったGatsbyのプラグイン: https://www.gatsbyjs.org/packages/gatsby-remark-prismjs/\ngatsby-config.jsには、プラグインの記事に従ってプラグインを追加。\nまた、gatsby-browser.jsに以下を追加\nrequire(\u0026quot;prismjs/themes/prism-solarizedlight.css\u0026quot;);\n行数を表示するには、更に以下を追加\nrequire(\u0026quot;prismjs/plugins/line-numbers/prism-line-numbers.css\u0026quot;);\nその他のthemeもあるので好きなのを使う。単一のラインのハイライトや、ハイライト開始/終了の行数指定も可能だが、自前でcssを調節する必要がある。\nコードハイライトにファイル名やタイトルを表示させたかったので、以下を使いました。\nhttps://www.gatsbyjs.org/packages/gatsby-remark-code-titles/?=gatsby-remark-code-titles\n例\n{ \u0026#34;test\u0026#34;: \u0026#34;test\u0026#34; } katex 記事中に数式を書くことがあるので、必要でした。以下のプラグインを使うと簡単にできます。\nhttps://www.gatsbyjs.org/packages/gatsby-remark-katex/\n\\tags 使うとparse errorで怒られる。(v3.1.13)\n前に使って重い印象があったので、使いませんでしたが、mathjaxもあるみたいです。\nhttps://www.gatsbyjs.org/packages/gatsby-remark-mathjax/\n画像表示 markdonwの記事に画像を追加します。 一般的には、![画像タイトル](URL)のように画像を追加しますが、gatsbyではプラグインを入れる必要があります。\nhttps://www.gatsbyjs.org/docs/working-with-images-in-markdown/\nただ、markdownで画像をリサイズして表示したいときは、どうするのかわからない。自前で作るしかない？？\n目次 プラグインgatsby-remark-tocを使うことで目次をつけることができます。ただ、記事のトップにしかつけることができず、Qiitaのようなサイドバーに目次をつけたかったので、以下のようにしました。\nqueryにtableOfContentsを加えると、目次が取得できます。\n例\nmarkdownRemark(fields: { slug: { eq: $slug } }) { html frontmatter { title date(formatString: \u0026quot;YYYY-MM-DD\u0026quot;) tags } tableOfContents } } 取得したものを表示します。\nconst tableOfContens = props.data.markdownRemarks.tableOfContents; \u0026lt;div dangerouslySetInnerHTML={{__html: tableOfContens}}/\u0026gt; 参考\nhttps://nakawork.net/posts/gatsby-toc\nスクロールで目次のハイライトもスクロールも試したかったけど、それはまた今度\ngoogle analytics https://www.gatsbyjs.org/packages/gatsby-plugin-google-analytics/\ngoogle adsense $ npm install --save gatsby-plugin-google-adsense\n// In your gatsby-config.js file plugins: [ { resolve: `gatsby-plugin-google-adsense`, options: { publisherId: `ca-pub-xxxxxxxxxx` }, }, ] プロジェクトのrootディレクトリにstaticディレクトリを作成。\nstaticディレクトリ以下に、CNAMEファイル、ads.txtを追加。\nサイトマップ 以下のプラグインを使うことで、build時にsitemap.xmlが生成されます。\nhttps://www.gatsbyjs.org/packages/gatsby-plugin-sitemap/\n関連記事の表示 プラグインがないみたいです。以下の記事が参考になりそうです。今後試してみます。\n参考\nhttps://khalilstemmler.com/articles/gatsby-related-posts-component/\ngithub pages 参考\nhttps://www.gatsbyjs.org/docs/how-gatsby-works-with-github-pages/\nsubdomainの場合は、以下の手順\ngh-pagesをインストール\n$ npm install gh-pages --save-dev\n以下を追加\n{ \u0026#34;scripts\u0026#34;: { \u0026#34;deploy\u0026#34;: \u0026#34;gatsby build \u0026amp;\u0026amp; gh-pages -d public\u0026#34; } } デプロイ\n$ npm run deploy\nまとめ プラグインが豊富で基本的なことは全てプラグインを使えば実現できるので便利。ただ、プラグインに依存しすぎて、バージョン依存の問題とかで盛大に死にそうな未来がうっすら見える。\nGraphQLのコンセプトは面白いし使いやすいけど、コードの中にquery書くのはインデントあわなさすぎてしんどい。localhost:8000___graphqlでqueryが確認できるのでなんとか頑張れるけど、APIほしかった。\n今後は以下の記事がチューニングの参考になりそう\nGatsbyでGoogle Lighthouseで満点を取るブログを一から作る\nhttps://qiita.com/so99ynoodles/items/87e136d09644baac634c\nGatsbyプラグイン45選\nhttps://takumon.github.io/gatsby-starter-qiita/f18d04ac-9b1a-5ac8-8d43-8aa3d8f746a7/\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/edgwbs/book-reports-firebase-hosting/",
                "title": "Firebase Hostingを使ってみた",
                "section": "posts",
                "date" : "2019-10-10",
                "body": "Firebase Authenticationに続いて、Firebase Hostingも使ってみました。備忘録を残しておきます。\n今回は、Vue.jsをデプロイします。\nFirebase Hostingとは  Firebase Hosting は、ウェブアプリ、静的コンテンツと動的コンテンツ、マイクロサービス向けの高速で安全性の高いホスティングを提供します。\n  Firebase Hosting はデベロッパー向けの、本番環境レベルのウェブ コンテンツ ホスティングです。1 つのコマンドですばやくウェブアプリをデプロイすることができ、静的コンテンツと動的コンテンツの両方をグローバル CDN（コンテンツ配信ネットワーク）に配信できます。Firebase Hosting と Cloud Functions または Cloud Run を併用してマイクロサービスを構築し、Firebase にホスティングすることもできます。\n 引用： https://firebase.google.com/docs/hosting?hl=ja\n無料で手軽にアプリケーションを公開するにはすごく便利という印象。\nFirebaseでは、転送量を超えない限り、複数アプリケーションをデプロイできるので、本番環境だけでなく、テスト環境もほしいという場合には有効かと思います。Herokuの無料枠では起動している時間の制限などで実質１アプリケーションしか動かせませんでした。\nまた、Hostingで利用できる無料のストレージが１GBですが、ブログなどのようにどんどんコンテンツが増えていくサイトでなければ十分な量だと思います。画像などがある場合は、Firebase Storageなどを利用する手もあるかと思います。\n参考\nFirebaseの料金体系\n静的サイトホスティングの為のGCS/GAE/Firebase Hosting比較\nFirebase Hostingを使って公開したアプリはこちら\n三行で読書感想文を書いて、SNSでシェアできるサービスを作った\n準備 デプロイ用のコマンドラインツールをインストールします。\n$ npm install -g firebase-tools 以下のコマンドで、firebaseにログインします。\n$ firebase login プロジェクトで、初めてfirebaseを使う場合には、以下のコマンドでfirebaseを初期化します。\n$ firebase init 初期化すると、firebase.jsonが作成されます。Hostingやstorage、functionsなどのその他のfirebaseの設定を記述します。基本的にはここで生成されたfirebase.jsonを書き換えることなく利用できます。\nデプロイ 生成されたfirebase.jsonにデプロイ用のディレクトリは、publicと設定されているので、publicにアプリをビルドします。 Vue.jsのプロジェクトの場合は、以下のようにビルド。\n$ npm run build public以下に生成された成果物は、以下のコマンドでfirebaseにデプロイすることができます。\n$ firebase deploy 複数サイトをデプロイする 本番環境とテスト環境がほしい場合などには、複数サイトをデプロイしたです。\n(別のアプリをデプロイする場合は、プロジェクト変えるよね？普通？本番/テスト以外にどう使うんだろう??)\nfirebase.jsonのhostingの項目を以下のように書き換えます。\n{ \u0026#34;hosting\u0026#34;: [ { \u0026#34;target\u0026#34;: \u0026#34;env\u0026#34;, // 自分で定義した、一意なアプリの識別子 \u0026#34;public\u0026#34;: \u0026#34;app/public\u0026#34;, // ... }, { \u0026#34;target\u0026#34;: \u0026#34;prod\u0026#34;, // 自分で定義した、一意なアプリの識別子 \u0026#34;public\u0026#34;: \u0026#34;app/public\u0026#34;, // ... } ] } 次に以下のコマンドで、target名とプロジェクトのサイト名を対応付けます。\n# $ firebase target:apply hosting target-name resource-name $ firebase target:apply hosting env myapp-blog $ firebase target:apply hosting prod myapp-blog あとは、以下のコマンドでデプロイします。\n# $ firebase deploy --only hosting:target-name $ firebase deploy --only hosting:env $ firebase deploy --only hosting:prod ドメインを設定 Hostingのサイトの管理、「ドメインを接続」からドメインが設定できます。\n手順どおりで簡単に行なえます。\n証明書が入るまでに少し時間がかかったので気長に待ちましょう。\nちなみに、CNAMEでいけるかと思ったけど無理でした。\nまとめ Firebase Hostingを使って、アプリケーションのデプロイを行いました。\nデプロイは驚くほど簡単でした。ローカルで動いているアプリケーションをそのまま、デプロイできるのが良かったです。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/emacs/gopls-introduction/",
                "title": "emacsのgo lang用のlanguage serverをgoplsに乗り換える",
                "section": "posts",
                "date" : "2019-10-08",
                "body": "emacsでgo langを書くときに使っているlspのlanguage serverがbingoからgoplsに変わったので、emacsの設定も更新しておこうと思います。\nbingoは、golangの公式に取り込まれる形になったようですね。\nインストール ドキュメント通りです。\nhttps://github.com/golang/tools/blob/master/gopls/doc/user.md\n$ go get golang.org/x/tools/gopls@latest GO111MODULEをonにする必要がある人は、適宜onにしてあげてください。\nemacs golang用の設定は、現状以下のようになってます。\n(use-package go-mode :ensure t :commands go-mode :init (bind-key \u0026#34;C-c i\u0026#34; \u0026#39;gofmt-before-save) :config (add-hook \u0026#39;go-mode-hook #\u0026#39;lsp) ;; lsp-mode (add-hook \u0026#39;go-mode-hook (lambda () ;; company-goを使う (set (make-local-variable \u0026#39;company-backends) \u0026#39;(company-go)) (company-mode))) (add-hook \u0026#39;go-mode-hook \u0026#39;go-eldoc-setup) ) gopls for emacs setting\nhttps://github.com/golang/tools/blob/master/gopls/doc/emacs.md\n小さいプロジェクトなら、コードの補完、ドキュメント表示、定義ジャンプなど問題なく使えてます。\nただ、大きいプロジェクトとなると、補完やドキュメントを表示しようとするとタイムアウトしてしまうので、少し調整が必要みたいです。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/edgwbs/book-reports-firebase-cloud-functions/",
                "title": "Firebase Cloud Functionsを使ってTwitterのOGPを設定する",
                "section": "posts",
                "date" : "2019-09-30",
                "body": "Vue.jsで作ったWebAppをFirebase Hostingで公開し、そこでTwitter用のOGPを設定しようとしましたが、Twitterのクローラーがjavascriptを解釈できないということで、別途方法を考える必要がありました。そこで、Firebase Cloud Functionsを使ってtwitter：OGPを設定してみようと思います。\nFirebase Cloud Functionsとは\n Cloud Functions for Firebase を使用すると、Firebase 機能や HTTPS リクエストによってトリガーされたイベントに応じて、バックエンド コードを自動的に実行できます。コードは Google のクラウドに保存され、マネージド環境で実行されます。独自のサーバーを管理およびスケーリングする必要はありません。\n 引用： https://firebase.google.com/docs/functions/?hl=ja\n今回は、HTTPSリクエストをトリガーに使いましたが、FirebaseのDatabaseへの書き込みやGitHubのpush/commitなどもトリガーにできるようです。色々と便利に使えそうです。\nCloud Functions で可能な処理:\nhttps://firebase.google.com/docs/functions/use-cases?hl=ja\nFirebase Cloud Functionsで使える言語は、今のところNode.js(javascript)だけのようです。Google CLoud Functionsでは、Node.js(javascript)、python、（Golang）がサポートされているので今後このあたりの言語もサポートされるのではないでしょうか。 Firebase Cloud Functions用に、javascriptのライブラリが提供されており、どうしても別の言語で書きたいという場合でなければ、不便なく使えるかと思います。\n作ったアプリはこれ。\n三行読書感想文\nOGP設定 今回は、ページによって設定したいOGPが異なるため、ページごとに動的に設定する必要があります。\nページごとに異なる情報は、Firebase CloudStoreに保存してあるので、そこから取得します。\nまた、ツイッターのクローラーからのリクエストならばOGP用のページを返却し、通常のアクセスならばページを表示するというような振り分けも行います。\nリクエストが来てからのフローは以下の用になります\n リクエストの振り分け DBからデータの取得 リダイレクト or OGP設定  シンプルなリスポンス例 200を返すシンプルなfunctionsの例は以下\nimport * as functions from \u0026#39;firebase-functions\u0026#39;; export const share = functions.https.onRequest((req, res) =\u0026gt; { res.status(200).send(\u0026#34;hello world\u0026#34;); }) リクエストの振り分け Twitterのクローラーは、User-AgentがUser-agent: Twitterbotなので、これを使います。\nUAがTwitterbotの場合はOGPを設定し返却、それ以外の場合は通常のページへリダイレクトさせるようにします。\nUAは以下の用に取得できます。\nconst ua = req.header(\u0026#39;user-agent\u0026#39;); console.log(\u0026#39;ua:\u0026#39;,ua); リクエストを振り分けるために、エンドポイントをfirebase.jsonを修正します。\n/for_twitterにアクセスが来るとFunctionsが呼ばれ、それ以外は通常のページを返します。\n\u0026#34;rewrites\u0026#34;: [ { \u0026#34;source\u0026#34;: \u0026#34;/for_twitter/*\u0026#34;, \u0026#34;function\u0026#34;: \u0026#34;for_twitter\u0026#34; }, { \u0026#34;source\u0026#34;: \u0026#34;**\u0026#34;, \u0026#34;destination\u0026#34;: \u0026#34;/index.html\u0026#34; } ] Cloud Storeからデータを取得 Firebase Admin SDKを使うと、FunctionsからDB/Storageに対し管理者としてアクセスが可能になります。もちろんですが、サーバー側空だけでフロント側から使わないように注意です。\nサーバーに Firebase Admin SDK を追加する:\nhttps://firebase.google.com/docs/admin/setup?hl=ja\n環境変数にsevice accountを追加します。\nexport GOOGLE_APPLICATION_CREDENTIALS=\u0026#34;/home/user/Downloads/service-account-file.json\u0026#34; 以下のようにSKDの初期化を行います。\nimport * as admin from \u0026#39;firebase-admin\u0026#39;; admin.initializeApp({ credential: admin.credential.applicationDefault(), databaseURL: \u0026#39;https://\u0026lt;DATABASE_NAME\u0026gt;.firebaseio.com\u0026#39; }); あとは、adminを使って、firestoreへアクセス可能です。\nconst ref = admin.firestore().collection(\u0026#39;test\u0026#39;); ref.get().then((snapshot) =\u0026gt; { // ... データの取得などはドキュメント参考\nhttps://firebase.google.com/docs/firestore?hl=ja\nTwiter OGPの設定 以下の４つが設定できるようです。\n Summary Card Summary Card with Large Image App Card Player Card  Optimize Tweets with Cards\nhttps://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/abouts-cards\n今回はSummary Card with Large Imageを使います。ヘッダーに以下を追加します。\n\u0026lt;meta name=\u0026#34;twitter:card\u0026#34; content=\u0026#34;summary_large_image\u0026#34;\u0026gt;\u0026lt;/meta\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;imageURL\u0026#34;\u0026gt; UAがTwitterbotの場合は、以下の関数を利用し、headerを設定します。\nfunction buildHtmlWithPost (id: string, siteUrl:string, imageURL) : string { return `\u0026lt;!DOCTYPE html\u0026gt;\u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;twitter:card\u0026#34; content=\u0026#34;summary_large_image\u0026#34;/\u0026gt; \u0026lt;meta name=\u0026#34;twitter:title\u0026#34; property=\u0026#34;og:title\u0026#34; content=\u0026#34;タイトル\u0026#34;/\u0026gt; \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;${siteURL}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;${imageURL}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:image:width\u0026#34; content=\u0026#34;600\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;` } 正しく設定できているかは以下から確認できます。\nhttps://cards-dev.twitter.com/validator\nまとめ Firebase Cloud Functionsを使って、Twitter用のOGPを設定しました。\nHTTPSリクエストをトリガーにし、Firebase Storageから情報を取得、headerを付与し返却するという使い方でしたが、簡単に使うことができました。他のFirebaseのサービスへのアクセスは簡単なので、Firebaseを利用したいろいろなアプリケーションが簡単に作れそうです。他のトリガーなども使ってみたいと思います。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/edgwbs/book-reports-firebase-auth/",
                "title": "Vue.js + Golang + Firebase Authenticationでログイン処理",
                "section": "posts",
                "date" : "2019-09-28",
                "body": "Vue.jsとGolangでWebアプリケーションでFirebase Authenticationを使い、ログイン処理を行います。\nhttps://firebase.google.com/docs/auth/?hl=ja\nFirebaseの説明や導入などは、Qiitaにもわかりやすい記事がたくさん上がっているので、そちらを参考にしてください。\nVue.js側 VueCLI3を使い、typescriptのプロジェクトを作成します。今回は、vueのrouter guardは省略します。\n準備 npmからインストールします。\n$ npm install firebase firebaseの認証情報は、以下のドキュメントを参考に取得しておきます。\nhttps://firebase.google.com/docs/auth/web/password-auth?authuser=1\nsrc/main.tsにfirebaseをimportし、上記で取得した認証情報を貼り付けます。\nimport firebase from \u0026#39;firebase/app\u0026#39;; const fireBaseConfig = { apiKey: \u0026#39;*****\u0026#39;, authDomain: \u0026#39;*****.firebaseapp.com\u0026#39;, databaseURL: \u0026#39;https://******.firebaseio.com\u0026#39;, projectId: \u0026#39;*****\u0026#39;, storageBucket: \u0026#39;*****.appspot.com\u0026#39;, messagingSenderId: \u0026#39;******\u0026#39;, }; firebase.initializeApp(fireBaseConfig); ログイン処理 firebaseではemail+passwordの通常の認証に加え、GoogleアカウントやTwitter、Githubのアカウントでのログインが1つのメソッドだけで行えます。\nGoogleなどのアカウントでログインしたい場合は、あらかじめfirebaseから認証を許可するよう設定しておく必要があります。\nsignIn with email+password コンポーネントにfirebaseのログイン画面を作ります。以下はその例です。\nimport {Component, Vue} from \u0026#39;vue-property-decorator\u0026#39;; import firebase from \u0026#39;firebase/app\u0026#39;; @Component export default class Home extends Vue { private email: string = \u0026#39;\u0026#39;; private password: string = \u0026#39;\u0026#39;; private showPassword: boolean = false; private siginInWithEmail() { firebase.auth().signInWithEmailAndPassword(this.email, this.password) .then((res: firebase.auth.UserCredential) =\u0026gt; { if (res.user === null) { return new Promise\u0026lt;string\u0026gt;((_, reject) =\u0026gt; reject(\u0026#39;user not found\u0026#39;)); } return res.user.getIdToken(); }) .then((idToken: string) =\u0026gt; alert(\u0026#34;login success\u0026#34;)) .catch((err) =\u0026gt; console.log(err)) .finally(() =\u0026gt; console.log(\u0026#39;end\u0026#39;)); } 見て分かる通り、以下のメソッドの引数にメールアドレスとパスワードを渡すだけです。\nfirebase.auth().signInWithEmailAndPassword(this.email, this.password)\nこのメソッドは、Promise\u0026lt;firebase.auth.UserCredential\u0026gt;を返します。 User情報などはここから取得できます。\nUserCredentialの中身は以下のドキュメントを参考。\nhttps://firebase.google.com/docs/reference/js/firebase.auth.html#usercredential\nfirebase.auth.UserCredentialのもつuserがgetIdTokenメソッドを持っており、ここからトークンが取得できます。\nPWAやスマホアプリでは、リフレッシュトークンを使いたいです。getIdTokenでは、トークンが失効していれば、firebase側でリフレッシュトークンを使ったトークンの更新処理を行ってくれるため、わざわざトークンの更新処理を追加する必要がありません。\nhttps://firebase.google.com/docs/reference/js/firebase.User.html#getidtoken\nsignIn with Google(popup) ログイン方法には、Popupで別ウィンドウが開きログインを行う方法とリダイレクトを用いた方法があります。 Googleアカウントを使いpopupでログインしたい場合は、以下のようにします。\nimport {Component, Vue} from \u0026#39;vue-property-decorator\u0026#39;; import firebase from \u0026#39;firebase/app\u0026#39;; private provider = new firebase.auth.GoogleAuthProvider(); @Component export default class Home extends Vue { private signInByGoogleWithPopup() { firebase.auth().signInWithPopup(this.provider) .then((res: firebase.auth.UserCredential) =\u0026gt; { // 省略 providerにGoogleを指定し、firebase.auth().signInWithPopup(this.provider)を呼ぶと、popupで見慣れたログイン画面が表示されます。 図\nfirebase.auth().signInWithPopup(this.provider)もEmail+Passwordの場合と同様に、Promise\u0026lt;firebase.auth.UserCredential\u0026gt;を返すので、同様の方法でtokenやuser情報を取得できます。\nsignIn with Google(redirect) PWAでは、リダイレクトでのログインが推奨されています。\nリダイレクトは以下のようにします。\nprivate siginInByGoogleWithRedirect() { firebase.auth().signInWithRedirect(this.provider) .catch((err) =\u0026gt; { console.log(err); }) .finally(() =\u0026gt; { console.log(\u0026#39;end\u0026#39;); }); } siginInByGoogleWithRedirectが呼ばれるとログイン画面にリダイレクトされます。\nログイン画面から元のページへ遷移後、リダイレクトによる認証が正しく行えたか確認します。\nprivate afterRedirect() { firebase.auth().getRedirectResult() .then((res: firebase.auth.UserCredential) =\u0026gt; { // 省略 getRedirectResultがfirebase.auth.UserCredentialを返すので、正しく認証できていれば、ここから先ほどと同様にユーザー情報やトークンを取得できます。\ngithub or twitter Googleアカウントを使った場合と同様に、プロバイダを指定しログインできます。 予めTwitterでデベロッパーアプリケーションとしてアプリを登録し、APIキーとAPI Secretを取得しておきます。 Twitterデベロッパー側に、OAuthコールバックとして、firebaseのURLを指定します。\nprovider = new firebase.auth.GithubAuthProvider(); // or provider = new firebase.auth.TwitterAuthProvider(); firebase.auth().signInWithPopup(provider) https://firebase.google.com/docs/auth/web/github-auth?hl=ja https://firebase.google.com/docs/auth/web/twitter-login?hl=ja\nパスワードの再設定 パスワードの再設定のメールを送信するのも、メソッド1つで行えます。\nfirebase.auth().sendPasswordResetEmail(this.email) 送信されるメールのbodyは、firebaseから設定が行えます。\nユーザーの更新、削除も同様に行えます。 詳しくはドキュメントを参考。\nhttps://firebase.google.com/docs/auth/web/manage-users?hl=ja#top_of_page\nメールアドレスの重複 Firebase Authenticationでは、メールアドレスの重複はデフォルトでは許可されていません。 Email+Passwordでアカウントを作成し、同じメールアドレスのGoogleアカウントでログインしようとすると、Googleアカウント側が有効となります。 このとき、ユーザー識別子は、Email+Passwordで作成したものが、Googleアカウントで作成したものに移行されるようです。\n重複を許可する設定も行えますが、1つのユーザーに複数のプロバイダを紐づけることもできるので、そちらを行った方が良いかと思います。 https://firebase.google.com/docs/auth/web/account-linking\n認証状態の永続性 https://firebase.google.com/docs/auth/web/auth-state-persistence?hl=ja\nGolang側 フロントで取得したJWTを、バックエンドに投げ、バックエンドからJWTが正しいかをfirebaeに問い合わせに行きます。\nユーザーのログインのフローは簡単に書くと以下の図のような流れになります。\nコード例は、以下の用になります。\nctx := context.Background() var opt option.ClientOption // localのjson keyから認証する場合 opt = option.WithCredentialsFile(\u0026#34;****.json\u0026#34;) // 環境変数から認証する場合 credentials, err := google.CredentialsFromJSON(ctx, []byte(authKey)) if err != nil { fmt.Println(err.Error()) os.Exit(1) } opt = option.WithCredentials(credentials) app, err := firebase.NewApp(context.Background(), nil, opt) if err != nil { fmt.Println(err.Error()) os.Exit(1) } client, err := app.Auth(context.Background()) if err != nil { log.Fatalf(\u0026#34;error getting Auth client: %v\\n\u0026#34;, err) os.Exit(1) } // ヘッダーからIDトークンを取得 authHeader := c.GetHeader((\u0026#34;Authorization\u0026#34;)) idToken := strings.Replace(authHeader, \u0026#34;Bearer \u0026#34;, \u0026#34;\u0026#34;, 1) // トークンを確認 token, err := client.VerifyIDToken(context.Background(), idToken) if err != nil { log.Fatalf(\u0026#34;error verifying ID token: %v\\n\u0026#34;, err) } log.Printf(\u0026#34;Verified ID token: %v\\n\u0026#34;, token) 参考 https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ja\nまとめ Vue.jsとGolangからFirebase Authenticationを使いユーザーの管理を行いました。 これまで、ユーザー管理用のAPIを自分で書いていましたが、バックエンドもフロントエンドも少しコードを書くだけで認証が行えるfirebase、めっちゃ楽、すばらしいです.\n一方、firebaseは認証トークンにJWT(json web token)を使っており、JWTは使うべきでないというような記事も割と見かけるので、この辺りはもう少し詳しく調べて見ようかと思います。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/edgwbs/book-reports-review/",
                "title": "三行で読書感想文を書いて、SNSでシェアできるサービスを作った",
                "section": "posts",
                "date" : "2019-09-25",
                "body": "サービス概要 「読書感想文をもっと気軽に」をコンセプトに読んだ本の感想文/レビューを三行だけ書き、SNSでシェアするサービスです。\n三行読書感想文\n使い方 googleアカウントもしくは、Twitterアカウントでログインできます。\nその他のSNSアカウントでのログインは、随時対応していこうと思います。\nログイン後に、感想を書く本を選びます。\nあとは、感想を書き、保存します。\n保存後にシェアします。\nこれだけの単純な作りです。\n作った動機  Firebaseを使いたかった 本に出会える場を増やしたかった  1.Firebaseを使いたかった 単純にFirebaseのみでサービスを稼働させたかっただけです。これまでFirebase Authは使ったことがありました。これがすごく便利で、びっくりしました。今まで、アカウント管理のAPIを頑張って作ってたのを肩代わりしてくれるなんて。そこで、それ以外のサービスを使ってみようと言うのが動機です。\n今回、Webアプリケーションで使えるDBやStorage、HostingなどFirebaseのサービスはほぼ使っています。すごく便利。使ってみた技術は、別の記事にまとめます。\n2.本に出会える場を増やしたかった 個人的な意見として、本とのファーストコンタクトは、タイトルや表紙、帯に書いてあるコメントなどパッと目に入ってくるものが多いです。本の感想やレビューを三行に絞ることで、書く側も読む側も気軽に使え、新たな本に出会える場となるのではないかと考えました。普段、本を読むことが少ない人は、こういった気軽な出会いから本を読んでみるのも良いのではないかと思います。\nまた、本を多く読む人も、多く読むからこそ、この本読んだけどどんな話だっけ？となることが多いかと思います。\nそういった場面で、短く感想を残しておくことで、自分自身の読んだ本の記録にもなるかと思います。\nまとめ Firebaseを使うことで、実質コーディングしたのは、フロントのVue.jsだけでした。DBやストレージへのアクセス、アカウント管理周りなどをFirebaseに任せられることで、APIを書く必要がないのは、コーディングする上で大きな負荷の軽減となりました。無料でここまで使わせてくれるのは、なにかサービスを簡単に始めたい時はとても便利だと思います。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/python/python-matplotlib-base/",
                "title": "matplotlibのよく使う記法まとめ",
                "section": "posts",
                "date" : "2019-09-24",
                "body": "すぐ忘れるので、matplotlibのよく使う記法をまとめておく\n公式：https://matplotlib.org/gallery.html\n普段は散布図とかplotとかしか使わないけど、こうして見るといろんなグラフがかけるみたい\nmatplotlib,pyplot,pylabの違い matplotlibがパッケージ全体\npyplotはそのモジュール、スクリプトで作図するときに使う\npylabのimportは推奨されてない模様、インタラクティブな作図にはこっちを使うらしい\n基本的には、import matplotlib.pyplot as pltのように使う\n参考：\nhttps://matplotlib.org/faq/usage_faq.html#matplotlib-pyplot-and-pylab-how-are-they-related\nhttps://stackoverflow.com/questions/11469336/what-is-the-difference-between-pylab-and-pyplot\nグラフを描く シンプルな例は以下\nimport matplotlib.pyplot as plt import numpy as np x = np.arange(0,10,0.2) y = np.sin(x) plt.plot(x,y) plt.show() macでmatplotlibを呼ぶとValueError: unknown locale: UTF-8で怒られることがある。\nlocale周りの設定がおかしいため。以下を参考に直す。\nMac で ValueError: unknown locale: UTF-8 のエラーを解決したい\nhttps://www.lifewithpython.com/2016/09/python-ValueError-unknown-locale-UTF-8.html\nインスタンス化する plt.figure()でインスタンス化し、axesに対してプロットしていく\n多分この使い方が多いと思う\nimport matplotlib.pyplot as plt import numpy as np x = np.arange(0,10,0.2) y = np.sin(x) fig = plt.figure() ax = fig.add_subplot(111) ax.plot(x,y) plt.show() 以下のように描いても同じ\nfig, ax = plt.subplots(1, 1) ax.plot(x,y) plt.show() 複数のグラフを描く 複数のウィンドウに分けて描画 fig = plt.figure()の引数に適当にユニークな数字を入れておく。\nfigureに引数を与えることで、新たな図が生成される。\n参考： https://matplotlib.org/api/_as_gen/matplotlib.pyplot.figure.html\nimport matplotlib.pyplot as plt import numpy as np x = np.arange(0,10,0.2) y = np.sin(x) fig = plt.figure(1) ax = fig.add_subplot(111) ax.plot(x,y) fig = plt.figure(2) ax = fig.add_subplot(111) ax.plot(x,y) plt.show() 1つのウィンドウに複数のグラフを描画 1つのウィンドウに複数のグラフを描く場合は以下のようにする。\nfig = plt.figure() ax1 = fig.add_subplot(211) ax1.plot(x,y) ax2 = fig.add_subplot(212) ax2.plot(x,y) plt.show() 以下のように2つのグラフが描画される。\n以下のように描いても同じ、axesをタプルで受け取るのがちょっと気持ち悪い\nfig, (ax1, ax2) = plt.subplots(1, 2) ax1.plot(x,y) ax2.plot(x,y) plt.show() グラフの保存 savefigでグラフの保存が可能\nimport matplotlib.pyplot as plt import numpy as np x = np.arange(0,10,0.2) y = np.sin(x) fig = plt.figure() ax = fig.add_subplot(111) ax.plot(x,y) plt.savefig(\u0026#34;./test2\u0026#34;) 複数のグラフを描画した場合には、figureインスタンスに対してもsavefigが使える。\nimport matplotlib.pyplot as plt import numpy as np x = np.arange(0,10,0.2) y = np.sin(x) fig = plt.figure(1) ax = fig.add_subplot(111) ax.plot(x,y) fig.savefig(\u0026#34;./test1\u0026#34;) fig = plt.figure(2) ax = fig.add_subplot(111) ax.plot(x,y) fig.savefig(\u0026#34;./test2\u0026#34;) グラフを整形する グラフの線の色、太さ、線の種類などはよく使う。\nそれぞれ、color,linewidth,linestyleの引数を与えることで設定できる。\nimport matplotlib.pyplot as plt import numpy as np x = np.arange(0,10,0.2) y = np.sin(x) fig = plt.figure() ax = fig.add_subplot(111) ax.plot(x,y,color=\u0026#34;red\u0026#34;,linewidth=2,linestyle=\u0026#34;dashed\u0026#34;) plt.show() 引数の詳細は公式の以下のページから確認できる。\nhttps://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html\nタイトルや軸名をつける シンプルな例は以下\nimport matplotlib.pyplot as plt import numpy as np x = np.arange(0,10,0.2) y = np.sin(x) plt.plot(x,y) plt.title(\u0026#34;test\u0026#34;) plt.xlabel(\u0026#34;x\u0026#34;) plt.ylabel(\u0026#34;y\u0026#34;) plt.show() インスタンス化した場合は次のようにする。\nimport matplotlib.pyplot as plt import numpy as np x = np.arange(0,10,0.2) y = np.sin(x) fig = plt.figure() ax = fig.add_subplot(111) ax.plot(x,y) ax.set_title(\u0026#34;test\u0026#34;) ax.set_xlabel(\u0026#34;x\u0026#34;) ax.set_ylabel(\u0026#34;y\u0026#34;) plt.show() グラフの余白、幅を調整する plt.subplots_adjustで調整可能\nimport matplotlib.pyplot as plt import numpy as np x = np.arange(0,10,0.2) y = np.sin(x) plt.plot(x,y) plt.subplots_adjust(left=0.1, right=0.95, bottom=0.1, top=0.95) plt.show() わかりづらいが調整できてる。\n調整前 調整後 デフォルト値は以下\nleft = 0.125 # the left side of the subplots of the figure right = 0.9 # the right side of the subplots of the figure bottom = 0.1 # the bottom of the subplots of the figure top = 0.9 # the top of the subplots of the figure wspace = 0.2 # the amount of width reserved for space between subplots, # expressed as a fraction of the average axis width hspace = 0.2 # the amount of height reserved for space between subplots, # expressed as a fraction of the average axis height 1つのウィンドウに複数のグラフを描画し軸名など入れた場合、グラフが重なることがある。\nその場合は、plt.subplots_adjust(hspace=0.4)のように調整できる。\n横幅は、wspaceで調整可能。\nfig = plt.figure() plt.subplots_adjust(hspace=0.6) ax1 = fig.add_subplot(211) ax1.plot(x,y) ax2 = fig.add_subplot(212) ax2.plot(x,y) plt.show() 調整前\n調整後\n参考：https://www.haya-programming.com/entry/2018/10/11/030103\n軸を設定し直す ちょっとめんどくさい\nimport matplotlib.pyplot as plt import numpy as np x = np.arange(0,10,0.2) y = np.sin(x) fig = plt.figure() ax = fig.add_subplot(111) ax.plot(x,y) ticks = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; plt.xticks(x,list(ticks)) plt.show() 設定し直したい次元と、元の軸の次元が合ってなくても設定できる模様。\nx軸に時刻を設定、フォーマット datetimeをそのままx軸に利用できる。\nimport matplotlib.pyplot as plt import pandas as pd x = [ \u0026#39;2018/08/08T12:15:45.000\u0026#39;, \u0026#39;2018/08/08T12:15:45.200\u0026#39;, \u0026#39;2018/08/08T12:17:45.600\u0026#39; ] x = pd.to_datetime(x,format=\u0026#39;%Y/%m/%dT%H:%M:%S.%f\u0026#39;) y = [1,2,3] fig = plt.figure() ax = fig.add_subplot(111) ax.plot(x,y) plt.show() フォーマットは、ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d\\n%H:%M'))を使って行う。\nimport matplotlib.pyplot as plt import pandas as pd import matplotlib.dates as mdates x = [ \u0026#39;2018/08/08T12:15:45.000\u0026#39;, \u0026#39;2018/08/08T12:15:45.200\u0026#39;, \u0026#39;2018/08/08T12:17:45.600\u0026#39; ] x = pd.to_datetime(x,format=\u0026#39;%Y/%m/%dT%H:%M:%S.%f\u0026#39;) y = [1,2,3] fig = plt.figure() ax = fig.add_subplot(111) ax.plot(x,y) ax.xaxis.set_major_formatter(mdates.DateFormatter(\u0026#39;%m/%d\\n%H:%M\u0026#39;)) plt.show() 参考：https://hack-le.com/matplotlib-x-date-format/\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/neuralnet/pepar-summary/",
                "title": "Deeplearningまわりの最新論文を浅く広くみてまわる",
                "section": "posts",
                "date" : "2019-09-24",
                "body": "最新論文の情報を広く浅く集めたい場合の巡回するサイトたちをまとめておきます。\nおすすめがあれば教えてください。\nGoogle Scholar: https://scholar.google.com/schhp?hl=ja\n研究者やキーワードが決まっていると探しやすい。ただ、ザッピングには向かない。\nいろいろ論文の検索エンジン使ってたけど、結局これが残った。texの引用が楽\narXiv arXiv https://arxiv.org/\nトップページは慣れないとちょっと見づらい。有名な研究者で検索したものや分野で絞り込んだものをチェックするのが使いやすそう。\narXivTimes https://medium.com/@arxivtimes\n日本語、arXivのまとめ系、ツイッター\n論文まとめてくれてるGitHub https://github.com/dennybritz/deeplearning-papernotes\narXivのまとめ。古いものは2011年から、新しいものは2018まで更新がある。\n企業の論文 DeepMind https://deepmind.com/research/publications/\nMicrosoft Research Publications http://research.microsoft.com/apps/catalog/default.aspx?t=publications\u0026amp;ra=47200\nGoogle Research Publications http://research.google.com/pubs/ArtificialIntelligenceandMachineLearning.html\nYahoo! Labs http://labs.yahoo.com/publication/?area=machine-learning\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/others/http-portal-for-blog/",
                "title": "Hugoで作ったwebサイトを公開する",
                "section": "posts",
                "date" : "2019-09-24",
                "body": "はじめに GCE上にdockerコンテナを使って、hugoの静的ファイルを公開してます。\nいろいろwebサービスを作ったりはしますが、公開するのは初めてだったので、いろいろと苦労した点をまとめておきます。\nインフラ GCEを使います。ほんとは、image化してインスタンスグループで公開したかったのですが、とりあえず、コンテナをVM上にデプロイすることにします。\nドメイン ドメインは、お名前.comで取得します。これは特に説明なしでいけます。\nDNSは、route53を使いたかったんですが、今回はgoogleのcloud DNSを使います。\nGoogle Cloud Consoleから、「ネットワークサービス」→「Cloud DNS」を選択します。\n任意のゾーン名、取得したドメイン、(説明)を入力して作成。\nAレコードの登録 DNS名には、www.取得したドメイン、リソースタイプにはAレコードを設定し、作成します。\nレジストラへの登録 生成されるNSレコードのns-cloud-c1.googledomains.com.をお名前.com側に登録します。\nhttps化 let\u0026rsquo;s encryptを使ってhttps化しようと思っていたところ便利なものを発見したのでこちらを使います。\nhttps-portal\n自動で証明書の更新も行ってくれます。すごい。便利。\n親切にdocker-composeが公式に載せてあるので、参考にします。 docker-composeのインストールはpipなどで行ってください。\nhttps-portal: image: steveltn/https-portal:1 ports: - \u0026#39;80:80\u0026#39; - \u0026#39;443:443\u0026#39; links: - wordpress restart: always environment: DOMAINS: \u0026#39;wordpress.example.com -\u0026gt; http://wordpress:80\u0026#39; # STAGE: \u0026#39;production\u0026#39; # FORCE_RENEW: \u0026#39;true\u0026#39; wordpress: image: wordpress links: - db:mysql db: image: mariadb environment: MYSQL_ROOT_PASSWORD: \u0026#39;\u0026lt;a secure password\u0026gt;\u0026#39; imageのバージョンは:1と指定しましょう。最新版を取ってくるようになります。\nimage: steveltn/https-portal:1 1.2以下だと、let\u0026rsquo;s Encryptで証明書を取得する際にエラーが起きるので注意です。\nlinks: - wordpress linksで公開するサービス名を指定しましょう。\nenvironment: DOMAINS: \u0026#39;wordpress.example.com -\u0026gt; http://wordpress:80\u0026#39; 環境変数のDMAINSでは、リクエストを受けるドメイン -\u0026gt; https化したいエンドポイントを指定します。\nlinksで指定したエイリアスで指定できます。また、-\u0026gt;を=\u0026gt;に変更することでリダイレクトができます。\nSTAGEは、次の3つが指定できます。\n STAGE: 'local'でオレオレ証明書を作成します。テストなどに STAGE: 'staging'でテスト用の証明書を作成します。 STAGE: 'production'で本番用に、Let\u0026rsquo;s Encryptで正式な証明書を作成します。  その他、環境変数も指定できます。この辺りを参考しながら、設定を行います。\nhttps://github.com/SteveLTN/https-portal/tree/master/fs_overlay/var/lib/nginx-conf\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/neuralnet/combine-model/",
                "title": "kerasでモデルを結合する",
                "section": "posts",
                "date" : "2019-09-24",
                "body": "autoencoderなどを作っていると、保存や推論を行う上での再利用性を考え、encoderとdecoderは分けてModelを作りたいことがある。\nautoencoderの学習の際には、作成したencoderのModelとdecoderのModelを結合する。\nModelの結合は前はできなかった気がするが、できるようになっていたのでメモ。\nKerasのバージョンは、2.1.1\nまずは、シンプルなモデルを2つ作る。input→model1→model2→outputを作る。\ndef model1(): layer_input = Input(shape=(None, 10)) layer_output = Dense(10)(layer_input) model = Model(layer_input, layer_output) model.summary() return model def model2(): layer_input = Input(shape=(None, 10)) layer_output = Dense(10)(layer_input) model = Model(layer_input, layer_output) model.summary() return model まず、model1へのインプットを作る。model1のアウトプットをmodel2のインプットにし、Modelのインスタンスを作る。\nm1 = model1() m2 = model2() inp = Input(shape=(None, 10)) model1_output = m1(inp) out = m2(model1_output) model = Model(inp, out) model.summary() すると、こんな感じでモデルが結合できたのが確認できる。\nUsing TensorFlow backend. _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_1 (InputLayer) (None, None, 10) 0 _________________________________________________________________ dense_1 (Dense) (None, None, 10) 110 ================================================================= Total params: 110 Trainable params: 110 Non-trainable params: 0 _________________________________________________________________ _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_2 (InputLayer) (None, None, 10) 0 _________________________________________________________________ dense_2 (Dense) (None, None, 10) 110 ================================================================= Total params: 110 Trainable params: 110 Non-trainable params: 0 _________________________________________________________________ _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_3 (InputLayer) (None, None, 10) 0 _________________________________________________________________ model_1 (Model) (None, None, 10) 110 _________________________________________________________________ model_2 (Model) (None, None, 10) 110 ================================================================= Total params: 220 Trainable params: 220 Non-trainable params: 0 _________________________________________________________________ コード全体はこんな感じ。\nfrom keras.layers import Dense from keras.models import Model def model1(): layer_input = Input(shape=(None, 10)) layer_output = Dense(10)(layer_input) model = Model(layer_input, layer_output) model.summary() return model def model2(): layer_input = Input(shape=(None, 10)) layer_output = Dense(10)(layer_input) model = Model(layer_input, layer_output) model.summary() return model def main(): m1 = model1() m2 = model2() inp = Input(shape=(None, 10)) x = m1(inp) out = m2(x) model = Model(inp, out) model.summary() if __name__ == \u0026#39;__main__\u0026#39;: main() モデルインスタンスの再利用性が上がってて使いやすくなってる。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/others/aws-cli-at-pyenv/",
                "title": "pyenv環境でaws cli入れたらコマンドが見つからない",
                "section": "posts",
                "date" : "2019-09-24",
                "body": "pyenv環境でaws cli入れたらコマンドが見つからないって言われたので調べたメモ\nバージョン：pyenv:1.0.10\n公式通りにインストールする。\n$ pip3 install awscli --upgrade --user すると、\n$ aws -bash: aws: command not found コマンドが見つからない\u0026hellip;.\n調べると、$HOME/.localにインストールされるらしいので、パスを通す。\naws --version aws-cli/1.16.29 Python/2.7.13 Darwin/16.7.0 botocore/1.12.19 できた！\npyenvが問題なのかはわからん\u0026hellip;.\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/others/rust-macro-use-another/",
                "title": "Rustでmodule間にまたがるmacro呼び出し",
                "section": "posts",
                "date" : "2019-09-24",
                "body": "Rustのmacroをモジュール化して、別のモジュールから呼ぼうと思ったらうまくいかなかった。\n日本語の記事があまりなかったのと、自分の備忘録ようにメモを残しておく。\nrustのバージョンは1.27.0\n参考 https://github.com/rust-lang/book/issues/401\nマクロの書き方とか、rustのimport周りは意外と日本語記事があったので、そっちを参考に\nファイル構成 lib.rsでmodをまとめて、main.rsで呼ぶようなファイル構成にする。 このようにしておくと、main.rsのなかでmodを宣言しなくてよくなるし、また誰が誰を公開しているかわかりやすくなる（たぶん）。\ncrate/ src/ main.rs lib.rs mod1/ mod.rs macro.rs mod2/ mod.rs macro_run.rs この時、main.rsを実行すると、macro_run.rsの中の関数が呼ばれ、この関数内でmacro.rsに定義してあるマクロが呼び出されるとする。\n簡単に言うと、モジュール間に跨ったマクロ呼び出しが行いたい。\n書き方 main.rsでは、macro_run内にあるrun関数を呼ぶ。\n// main.rs  extern crate rust_test2; use rust_test2::mod2::macro_run; fn main() { macro_run::run(); } run関数内では、foo!というマクロを使う。\n// macro_run.rs  #[macro_use] use mod1::macro_test::*; pub fn run() { let foo = foo!(1); println!(\u0026#34;{}\u0026#34;,foo); } fooマクロは、引数をそのまま返す単純なマクロ。\n// macro.rs  #[macro_use] macro_rules! foo { ($e: expr) =\u0026gt; { $e } } macro_useをつける。\n// mod1/lib.rs  #[macro_use] pub mod macro_test; ここのlibにもmacro_useが必要。\n// lib.rs  #[macro_use] pub mod mod1; pub mod mod2; 次のように#[macro use]の順番が入れ変わるとだめ (参考：https://www.ncameron.org/blog/macros-in-rust-pt4/)\n// lib.rs  pub mod mod2; #[macro_use] pub mod mod1; まとめ  #[macro_use]をいっぱいかく lib.rsに書く順番が大切 コードの一部はネットの情報としてあったが、コードの全体がわからずハマったので全体をgithubにあげておく  https://github.com/if001/rust_macro_test\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/nlp/seqgan-paper/",
                "title": "SeqGANの論文を読む",
                "section": "posts",
                "date" : "2019-09-24",
                "body": "SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient\nhttps://arxiv.org/pdf/1609.05473.pdf\nSeqGANの論文を読んだのでまとめておきます。実装を行おうと思って読んだので手法をメインに読みます。 結果などは余力があれば加筆します。\nはじめに 文章生成では、LSTMcellを使ったRNNが優れたパフォーマンスを行う。一般的な学習法は対数尤度を最大化する方法だが、次のような問題点がある。\n exposure bias(予測時には、自分の出力から次の語を予測することによるbias) BLEUを使っても良いけど、詩やchatbotだと難しい  これらの問題に対して、General adversarial net(GAN)が有効そうである。ただし2つの問題がある。\n GANは連続データを生成するように設計されており、sequenceなどの離散データを直接生成するのは難しい。生成モデルGのパラメータの更新に識別モデルDの勾配を用いているが、微小な勾配により更新された生成モデルGに対応する出力値が離散のため存在しない可能性があるためである。 GANは、生成された文全体に対して、score/lossのみを与えることができる。部分的に生成されたsequenceには、文全体としての現在と将来のscoreのバランスをどのようにうまく取れば良いかが自明でない。  そこで、生成モデルに強化学習を用いたGANであるSeqGANを提案する。\nSequence Generative Adversarial Nets 生成モデル$G_ \\theta $はパラメータを$\\theta$として、$Y_ {1:T} = (y_ 1, y_ 2 , y_ T)$,$y_ t \\in \\mathcal Y$ を生成するために学習する。ここで、$\\mathcal Y$はvocabularyを表す。\n学習には、強化学習を用いる。時刻$t$において、状態$s$は現在の単語列$(y_ {1},y_ {2}, \\ldots ,y_ {t-1})$を表し、行動$a$により次の単語$y_ t$を選択する。このため、方策モデル$G_ {\\theta} (y_ {t}|Y_ {1:t-1})$ は確率的である。一方、行動を選択したあとでは、状態遷移は決定的である。つまり、もし現在の状態が$s=Y_ {1:t-1}$で行動が$a=y_ {t}$ならば、次の状態$s'=Y_ {1:t}$に対して、$\\delta^a_ {s,s'}=1$である。そうでないなら、次の状態$s''$に対して$\\delta^a_ {s,s''}=0$である。\n加えて、パラメーター$\\phi$を持つ識別モデル$D_ \\phi$は、生成モデル$G_ \\theta$を学習しながら正解を識別する。識別モデル$D_ \\phi$は、本物の文章かどうかを確率的に識別する。\n識別モデル$D_ \\phi$は、正解文章と生成モデル$G_ \\theta$から生成される不正解の文章を用いて学習する。同時に、生成モデル$G_ \\theta$は、期待値と$D_ \\phi$から得られる報酬に基づくMC searchにより学習する。\nSeqGAN via Policy Gradient 生成モデル(方策)$G_ \\theta(y_ t|Y_ {1:t-1})$の目的は、単語列$s_ 0$が与えら得た時に得られる期待値を最大化あすることである。\n$$ J(\\theta) = E[R_ t|s_ 0,\\theta ] = \\sum_ {y_ 1 \\in \\it Y} G_ \\theta (y_ 1|s_ 0)・Q^{G_ \\theta}_ {D_ \\phi}(s_ 0,y_ 1)$$\nここで、$R_ t$は、完全な文章に対する報酬を表す。この報酬は、$D_ {\\phi}$から得られる。これは後に記述する。$Q^{G_ \\theta}_ {D_ \\phi}(s_ 0,y_ 1)$は、方策$G_ \\theta$に従うaction-value functionである。\n続いて、どのようにaction-value functionを推定するかだが、これには強化学習と識別モデル$D_ \\phi$を報酬とし実際に推定される確率を用いる。\n式は次のように表される。 $$ Q^{G_ \\theta}_ {D_ \\phi}(s=Y_ {1:T-1},a=y_ T) = D_ \\phi(Y_ {1:T})$$\nただし、終了した文章に対してのみを識別モデルが生成する報酬として扱う。我々は、ステップごとに、長い期間の報酬を気にしているので、1つ前の単語の適応(fitness)だけについて考慮すべきでなく、将来の報酬についても考慮する必要がある。これは、ちょうど囲碁やチェスをゲームするのに似ている。\n中間状態に対して、action-valueを評価することについてだが、まだ観測していない$T-t$の単語をサンプリングするために、roll-out policy$G_ \\beta$を伴うMonte Carlo searchを適応する。\nN-time Monte Carlo searchは次のように定式化される。\n$$ { Y^1_ {1:T},\u0026hellip;,Y^N_ {1:T} } = MC^{G_ \\beta}(Y_ {1:t},N) $$\n実験では、$G_ \\beta$は、生成器と同様にセットされた。(速度が必要ならば簡易版でも良い)\n分散を下げ、またaction-valueのより良い精度を得るため、現在の状態から文章の最後までのN回のroll-out pulicyを実行して、出力サンプルのbatchを得る。 以上から、以下の定式化が行える。\n$$ Q^{G_ \\theta}_ {D_ \\phi}(s=Y_ {1:T-1},a=y_ T) = \\frac{1}{N} \\sum_ {n=1}^N D_ \\phi(T^n_ {1:T}, Y^n_ {1:T} \\in MC^{G_ \\beta}(Y_ {1:t};N)) , {\\rm for} , t \u0026lt; T$$\n$$ Q^{G_ \\theta}_ {D_ \\phi}(s=Y_ {1:T-1},a=y_ T) = D_ \\phi(T^n_ {1:T}, Y^n_ {1:T}) , {\\rm for} , t=T$$\n中間の報酬がないとき、関数は、状態$s'=Y_ {1:t}$から始まりrole-outの終わりまでのnext-state valueとして繰り返し定義される。\n識別モデル$D_ {\\phi}$を使った報酬は、生成モデルを繰り返し学習するために、動的に更新される。より現実的な文章のセットが生成されると、次のように識別モデルを更新する。\n$$ min_ \\phi - \\mathbb E_ {Y〜p_ {data}}[log D_ {\\phi}(Y)] - \\mathbb E_ {Y〜G_ {\\theta}}[log (1 - D_ {\\phi}(Y))] $$\nようは、クロスエントロピーである。 一方、生成モデルの目的関数$J(\\theta)$は、以下のようになる。\n$\\nabla_ {\\theta}J(\\theta) = \\sum_ {t=1}^{T} \\mathbb E_ {y_ {t}〜G_ {\\theta}(y_ t|Y_ {1:t-1})}[\\nabla_ {\\theta}logG_ \\theta(y_ t|Y_ {1:t-1})・Q_ {D_ \\phi}^{G_ \\theta}(Y_ {1:t-1,y_ t})]$\nここで、$Y_ {1:t-1}$は生成モデル$G_ \\theta$によりサンプリングされた観測される中間状態を表す。\nサンプリング手法で$\\mathbb E[・]$は近似することができるので、生成モデルのパラメーターは次のように更新される。\n$$ \\theta = \\theta + \\alpha \\nabla_ \\theta J(\\theta)$$\nここで、$\\alpha_ h$は$h$ステップ目の学習率を表す。勾配法としては、AdamかRMSpropを使う。\nThe Generative Model for Sequences 生成モデルとして、LSTMをつかう。\nThe Discriminative Model for Sequences 識別モデルには、CNNをつかう。\n入力文章を次のように表す。 $$ \\varepsilon_ {1:T} = x_ 1 \\otimes\tx_ 2 \\otimes \\dots \\otimes x_ t$$\nここで、$x_ t \\in \\mathbb R^k$はk次元にembeddingされた単語、$\\otimes$は行列$\\epsilon \\in \\mathbb R^{T \\times k}$ を生成するたのconcatenation operatorを表す。\nカーネル$ \\boldsymbol{w} \\in \\mathbb R^{l \\times k}$は、新しい特徴マップを生成するための$l$個の単語のwindow sizeへ適応する。(訳怪しい)\n$$c_ i = \\rho ( \\boldsymbol{w} \\otimes \\varepsilon_ {i:i+l-1}+b )$$\nここで、$\\otimes$は要素ごとの掛け算の和、$b$はバイアス、$\\rho$は非線形関数を表す。異なるwindow sizeの様々なカーネルを適応し特徴量を抽出する。最後に、特徴マップ$\\tilde{c}=max \\lbrace c_ 1,\\ldots,c_ {T-l+1} \\rbrace $上にmax-over-timeプーリングを適応する。\nパフォーマンス向上のためにthe pooled feature mapsに基づく、the highway architecture (Srivastava, Greff, and Schmidhuber 2015)を追加する。 最後に、活性化関数がシグモイド関数の全結合をつかい、正解か不正解の確率を出力する。 詳しい式は、appendixにかく。\n参考 http://hirotaka-hachiya.hatenablog.com/entry/2017/02/27/222611 https://mil-tokyo.github.io/paper-summary/papers/20170320-SeqGAN\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/nlp/word2vec-output-word/",
                "title": "word2vecでベクトルから単語を出力する",
                "section": "posts",
                "date" : "2019-09-24",
                "body": "word2vecで単語をベクトルにしたり、類似度判定した記事はたくさんあるが、ベクトルから類似単語を出力する日本語記事を見つけられなかったのでメモ。 stack overflowにあった。 https://stackoverflow.com/questions/32759712/how-to-find-the-closest-word-to-a-vector-using-word2vec\n結論 結論から言うと、以下のように適当にモデルを作りmost_simlar関数にベクトルを与えるだけ。\nsentences = gensim.models.word2vec.Text8Corpus(filename) model = Word2Vec(sentences, size=100, window=5, min_count=5, workers=4) model.most_similar( [ vector ], [], 1)[0][0] ただし、第3引数は出力する類似単語数を表す。\n使用例 青空文庫：江戸川乱歩の解析をしたので、その例を示す。\nmodel.wv[\u0026#34;ベクトル化したい単語\u0026#34;] で単語をベクトル化できる。\nsentences = gensim.models.word2vec.Text8Corpus(filename) model = Word2Vec(sentences, size=100, window=5, min_count=5, workers=4) vector = model.wv[\u0026#34;犯罪\u0026#34;] word = model.most_similar( [ vector ], [], 1) print(vector) print(word) 上記のようなコードを実行すると、\n[-0.01494294 -0.1509463 0.06123272 ..., 0.01335443 0.03439184 0.05130962] [(\u0026#39;犯罪\u0026#39;, 1.0000001192092896)] となり、「犯罪」をベクトル化し、そのベクトルから単語が出力できている。\n出力数を変更 vector = model.wv[\u0026#34;明智\u0026#34;] word = model.most_similar( [ vector ], [], 5) 以下のような結果が得られる。\n[(\u0026#39;明智\u0026#39;, 1.0000001192092896), (\u0026#39;名\u0026#39;, 0.8110731840133667), (\u0026#39;博士\u0026#39;,　0.8006758093833923), (\u0026#39;氏\u0026#39;, 0.7667115330696106), (\u0026#39;殿村\u0026#39;, 0.7487545609474182)] 単語のみを出力 単語のみを出力するために、以下のようにしておくとよい\nmodel.most_similar( [ vector ], [], 1)[0][0] 任意のベクトル入力 以下のようにして、任意のベクトルができる。\nvec = np.zeros(3000) vec[2] = 1 vec = np.array(vec,dtype=\u0026#39;f\u0026#39;) word = model.most_similar( [ vector ], [], 5) 出力結果\n[(\u0026#39;点い\u0026#39;, 0.04825586825609207), (\u0026#39;ワハハハハハハハハ\u0026#39;, 0.04788881167769432), (\u0026#39;珍奇\u0026#39;, 0.04669386148452759), (\u0026#39;憎らしい\u0026#39;, 0.04500409588217735), (\u0026#39;な\u0026#39;, 0.04486800357699394)] まとめ most_similar使えばいける。ちなみに公式には、model.wv.most_similarって書いてあったけど、wvなくてもできた。公式には、ベクトルは、model.wvのKeyedVectorsインスタンスに保存されてるって書いてあったけどよくわかってない。 今回は総単語数19002だったのだが、実行時間は1分ほど。word2vec高速すごい。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/nlp/diversity-neural-conversation-model/",
                "title": "ニューラルネットワークを用いた対話モデルのための多様性を促進する目的関数",
                "section": "posts",
                "date" : "2019-09-24",
                "body": "Qiitaに投稿した記事、kerasでHREDを構築してみるの記事で、こちらの論文が参考になるとのコメント頂いて、読んで見たので簡単にまとめました。\nA Diversity-Promoting Objective Function for Neural Conversation Models https://arxiv.org/abs/1510.03055\n会話タスクにおける、入力文章(メッセージ)とそれに対する応答に多様性をもたせる手法を提案した論文です。 モデル周りをメインにそれ以外は軽く流し読みしているので、悪しからず。\nはじめに sequence to sequece(seq2seq)などの対話モデルでは、多様で文法的な応答が求められる。このモデルでは、入力される文章と出力される文章の対応のみを考慮しているため、I\u0026rsquo;m OKやI\u0026rsquo;dont knowのような高頻度フレーズを生成しがちである。したがって、メッセージに関する応答の依存性だけでなく、応答とメッセージの関係性についても考慮すべきである。\nそこで、私たちは、Maximum Mutual Information（MMI）を目的関数とする対話モデルを提案する。私たちは、MMIを使用することで、多様で興味深い文章を生成することを示します。\nMMIモデル seq2seqモデルの標準的な目的関数は以下のように表される。\n$$\\hat{T} = argmax_T{\\log p(T|S)}$$\n$N$は単語数を表し、入力文章(メッセージ)$S$とそれに対する応答$T$は以下のように表される。 $S = {s_1, s_2, \u0026hellip;, s_{N_s} }$ $T = {t_1, t_2, \u0026hellip;, t_{N_t}, EOS}$\nseq2seqモデルの目的関数を以下のように修正する。\n$$\\hat{T} = argmax_T {\\log p(T|S) - \\log p(T)}$$\nこのとき、argmaxの中身は、以下のように式変形から、相互情報量(wikipedia) を表していることがわかる。\n$${\\log p(T|S) - \\log p(T)} = \\frac{\\log p(S,T)}{\\log p(S) \\log p(T)}$$\nしたがって、この式は、相互情報量を最大化(MMI)する応答を出力することとなる。\nまた、$\\log p(T)$は、seq2seqの標準的な目的関数に対するペナルティ項とみなすことができる。メッセージに対するありふれた応答に対してペナルティを与えることで、応答の多様性を保つことを期待している。\nこのペナルティー項を調節できるように、(2)式に対して、パラメタ$\\lambda$を追加する。これを、MMI-antiLMと呼ぶ。\n$$\\hat{T} = argmax_T {\\log p(T|S) - \\lambda \\log p(T)} \u0026ndash;(1)$$\n式(3)をベイズの定理を用いて変形すると、以下のようになる。これをMMI-bidiと呼ぶ\n$$\\hat{T} = argmax_T {(1-\\lambda)\\log p(T|S) + \\lambda \\log p(S|T)} \u0026ndash;(2)$$\nMMI-bidiでは、$p(T|S)$と$p(S|T)$がトレードオフの関係にあることがわかる。\nseq2seqモデルの学習にMMIを適応させることは、重要ではない。さらに、モデルの訓練に時間がかかるので、訓練なしに$\\lambda$を調整したい。そこで、モデルを訓練するのではなく、学習時には最尤モデルを、テスト時にMMI基準を使用する。\n実用的な考察 MMI-antiLMとMMI-bidiを適応するにあたり、\n 文法的におかしな応答 (MMI-antiLM) デコードを困難にする (MMI-bidi)  という問題があり、直接decodingに適応するのは困難である。\nそこで、これらの問題について、以下で解決策を説明する。\nMMI-antiLM(an anti-language model) 式(1)の第2項の$p(T)$は、次のように表される。\n$$ p(T) = \\prod_ {k=1}^{N_ t} p(t_ k \\mid t_ 1 , \\cdots , t_ {k-1} ) $$\nanti-language modelでは、流暢な応答にもペナルティを与えるので、誤った文法の出力に繋がる可能性がある。そこで、$P(T)$に現在の単語$k$に基づく重み$g(k)$を乗算した、$U(T)$を導入する。\n$$ U(T)=\\prod_ {k=1}^{N_ t} p(t_ k \\mid t_ 1 \\cdots t_ {k-1} )・g(k) $$\n\\begin{eqnarray} g(k) \\begin{cases} 1 \u0026amp; ( k \\leq \\gamma ) \\\\\\\n0 \u0026amp; ( k \\gt \\gamma ) \\end{cases} \\end{eqnarray}\nここで、$\\gamma$は文頭から数えて何単語目かを表す閾値である。\n式（1）は、以下のように書き直すことができる。\n$$\\hat{T} = argmax_T {\\log p(T|S) - \\lambda \\log U(T) }$$\nこうすることで、メッセージにおける全ての単語に対して、ペナルティを与えるわけではなく、初めの何単語かにだけペナルティを与えることで、典型的なパターンがくるのを避けることを期待する。\nMMI-bidi 式（2）の第2項には、$p(S|T)$が含まれている。\n$$\\hat{T} = argmax_T {(1-\\lambda)\\log p(T|S) + \\lambda \\log p(S|T)}$$\n$p(S|T)$は、応答$T$の生成後でないと計算することはできない。また、応答$T$の探索空間が広すぎるために、全てを探索するのは難しい。したがって、この式を用いて直接decodeすることはできない。\nそこで、近似的なアプローチを行う。\n MMI-bidiの第1項である$p(T|S)$ (すなわち、標準的なseq2seqの目的関数)を与えられた第1世代N-bestリストを生成 MMI-bidiの第2項を使ってN-bestリストをrerankする 一般的に、標準的なseq2seqモデルから得られるN-bestは文法的であるため、最終的に選択されるoptionsは適切な文法である可能性が高い。  Training  encoderとdecoderはそれぞれ4層のLSTMから構成 隠れ層は1000個の素子、単語埋め込み数の次元は1000次元 LSTMパラメタと埋め込みは a uniform distribution in [−0.08, 0.08]で初期化 SGDの学習率は0.1 バッチサイズは256 Gradient clipping is adopted by scaling gradients when the norm exceeded a threshold of 1  decoding MMI-antiLM MMI-antiLMの式は簡単に実装できる。 実験において、応答の長さも重要だと気づいた。そこで、損失関数に応答の長さのパラメタを加えた。\n$$ Score(T) = p(T|S) - \\lambda U(T) + \\gamma N_t$$\nここで、$N_t$はターゲットの長さ、$\\gamma$はその重みを表す。 応答の候補のN-best listに関するMERTを使って、$\\gamma$と$\\lambda$を最適化した。\nMMI-bidi 結果 評価には、BLEUを使う。さらに、生成された応答における異なるユニグラムおよびバイグラムの数を計算し、多様性を評価する。\nTwitter Conversation Triple Dataset 129Mのメッセージと応答の集合から、2300万の会話スニペットを使用。\nstatistical machine translation (SMT)とseq2seqとの比較を行った。　MMI-bidiのBLEU評価値が一番高い。\nOpenSubtitles Dataset 60M、70Mのノイズを多く含む、映画キャラクターの対話データ\n他のモデルに比べ、MMI-antiLMモデルがBLEUの評価値と多様性の評価値どちらにおいても最も高くなった。MMI-bidiがMMI-antiLMより低い性能となったのは、N-bestリストの初期世代に左右されるからである。\nまとめ seq2seqを使った対話モデルでは、メッセージに対する応答が、一般的でありふれたものになる傾向があるという問題点があった。我々の分析では、これは、入力（メッセージ）を与えられた出力（応答）の単方向尤度の使用に起因することを示唆している。そこで目的関数に最大相互情報量(MMI)を使用することを提案した。実験の結果、提案されたMMIモデルでは、より多様で興味深い応答を生成することができた。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/nlp/char-vec/",
                "title": "文字をベクトル化する",
                "section": "posts",
                "date" : "2019-09-24",
                "body": "文章生成にchar-level lstmを使ってみる。英語ではうまくいっている例があるが日本語では難しい。これは、日本語は英語に比べ文字数が多く、ニューラルネットワークの次元数(パラメータ数)が増やす必要があるのが原因の1つだと思う。また、次元削減のため、日本語では文章を単語に区切り単語をベクトル化し、lstmで文章を生成する手法もあるが、単語に区切る時点でしゃべり言葉やネットの言葉ではうまく区切れないという問題がある。そこで、日本語の文字を画像として生成し、その画像をauto-encoderを用いてベクトル化することで、文字のベクトル化を行い、lstmに食わせるという手法を試して見ようと思う。\n今回は、auto-encodeを用いた文字レベルのベクトル化までを行ってみようと思う。\nコードはここ、https://github.com/if001/fifc.git\n以下の3工程で行う。\n フォントファイルからフォント画像を生成 文字列とフォント画像をマッピング フォント画像から特徴量を生成  フォントファイルからフォント画像を生成 フォントファイルは、PILのImageFontのturetypeを使い読み込むことができる。\nフォントファイルとフォントのサイズを引数に与えることで、fontオブジェクトが生成できる。\nfrom PIL import ImageFont font_size=28 font = ImageFont.truetype(font_file, font_size, encoding=\u0026#39;unic\u0026#39;) 読み込んだフォントは下記のように保存する。\nfrom PIL import Image pict_height=28 pict_width=28 image = Image.new(\u0026#39;RGB\u0026#39;, (pict_height, pict_width), (255, 255, 255)) draw = ImageDraw.Draw(image) draw.text(pos, yomi, font=font, fill=\u0026#39;#000000\u0026#39;) image.save(\u0026#34;./font\u0026#34;, \u0026#39;PNG\u0026#39;) Image.new() で空のイメージを生成し、\nDrawオブジェクトに対しのtext関数を用いてフォントファイルを書き込む。\ndraw.text(pos, yomi, font=font, fill='#000000') 引数は、上記のtext関数のリンクを参照。\n保存するファイル名は、以下のように文字を16進数変換したものを使う。\nyomi=\u0026#34;歩\u0026#34; bytes_yomi = yomi.encode(\u0026#34;UTF-8\u0026#34;).hex() \u0026gt;\u0026gt; \u0026#39;e6ada9\u0026#39; 文字列とフォント画像をマッピング ファイル名を読み仮名を16進数変換し保存しているので、文字から毎回画像ファイルを読み込んでも良いが、高速に呼び出せるように、1文字と画像をファイルとkvsを使ってマッピングしておく。\nkvsにはplyvelを使う。以下のようにインスタンス化する。\nimport plyvel db = plyvel.DB(db_path, create_if_missing=True) 以下のように、保存と取り出しを行う。\ndb.put(key, value) # 保存 db.get(key) # 取り出す フォント画像から特徴量を生成 auto-encoderを使って、保存した画像から特徴量を抽出する。\nモデルの構造はkerasの公式ブログを参考にし、以下の構造とした。\n各層の次元は以下のようにした。\nfont_size = 32 input_img = Input(shape=(font_size, font_size, 1)) x = Conv2D(16, (3, 3), padding=\u0026#39;same\u0026#39;)(input_img) x = BatchNormalization()(x) x = ReLU()(x) x = MaxPooling2D((2, 2), padding=\u0026#39;same\u0026#39;)(x) x = Conv2D(8, (3, 3), padding=\u0026#39;same\u0026#39;)(x) x = BatchNormalization()(x) x = ReLU()(x) x = MaxPooling2D((2, 2), padding=\u0026#39;same\u0026#39;)(x) x = Conv2D(self.hidden_dim, (3, 3), padding=\u0026#39;same\u0026#39;)(x) x = ReLU()(x) encoded = MaxPooling2D((2, 2), padding=\u0026#39;same\u0026#39;, name=\u0026#34;encoder\u0026#34;)(x) x = Conv2D(8, (3, 3), padding=\u0026#39;same\u0026#39;, name=\u0026#34;decoder\u0026#34;)(encoded) x = ReLU()(x) x = UpSampling2D((2, 2))(x) x = Conv2D(8, (3, 3), padding=\u0026#39;same\u0026#39;)(x) x = BatchNormalization()(x) x = ReLU()(x) x = UpSampling2D((2, 2))(x) x = Conv2D(16, (3, 3), padding=\u0026#39;same\u0026#39;)(x) x = BatchNormalization()(x) x = ReLU()(x) x = UpSampling2D((2, 2))(x) decoded = Conv2D(1, (3, 3), activation=\u0026#39;sigmoid\u0026#39;, padding=\u0026#39;same\u0026#39;)(x) autoencoder = Model(input_img, decoded) autoencoder.summary() 学習 損失関数と最適化関数はそれぞれ、mean_squared_errorとadamを用いた。\n教師データとバリデーションデータはそれぞれ、66918個、16730個とした。また、バッチサイズは128とした。\n学習は、kerasのearlystoppingを使いval_lossが減少がなくなるまで行った。\n結果 最中的なスコア\nepoch :4 acc :0.591411 loss :0.046486 val_acc :0.529843 val_loss:0.073542 だいぶ早めに学習が打ち切られているのがわかる。\n2epoch目くらいからほとんどlossもaccも変化しなくなっている。次元数や層の数が少なくパラメタが足りないのか???\n一応デコードされた文字を確認しておく。\n左が教師データ、右がdecodeされた文字となる。auto-encoderなのでぼやけているのはしょうがないが割と綺麗にデコードできている。ただし、画数の多い文字となるとやはりぼやけて元の文字がわからない。この辺は、モデルや学習のパラメタを調整することでも少し改善されると思う。\n生成された特徴量も確認しておく。\n以下に、\u0026lsquo;寂\u0026rsquo;, \u0026lsquo;,\u0026rsquo;, \u0026lsquo;ッ\u0026rsquo;, \u0026lsquo;鏡\u0026rsquo;, \u0026lsquo;奸\u0026rsquo;, \u0026lsquo;Ｐ\u0026rsquo;, \u0026lsquo;跳\u0026rsquo;, \u0026lsquo;・\u0026rsquo;, \u0026lsquo;“\u0026rsquo;, \u0026lsquo;ょ\u0026rsquo;の記号を含む10文字を与えた際の特徴量を図示する。 特徴量は、1文字あたり(4,4,8)次元となるので、4×4の画像を8枚横に並べたものを表示している。\n図をみると、文字ごとの偏りはなく学習できているように見える。\nlossは0.04とある程度小さい値となったが、accは0.6とそこまで高い値とはならなかった。改善のため何をすれば良いかの指標がいまいちわからん。損失関数と最適化関数は良さそうなので、とりあえず、層の数やunit数、学習率などのパラメタや教師データを増やすなど試してみようと思う。随時更新していく。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/others/tex-notation-numerical-formula/",
                "title": "機械学習系の数式によく出てくる記号などのTex表記まとめ",
                "section": "posts",
                "date" : "2019-09-24",
                "body": "すぐ忘れるのでTex表記をまとめて起きます。 Qiitaが使っているというEasy Copy MathJaxを用います。\n   読み 表示 tex     デルタ $\\Delta$ \\Delta   ナブラ $\\nabla$ \\nabla   白抜き $\\mathbb E[\\cdot]$ \\mathbb E[\\cdot]   属する $\\in$ \\in   要素 $\\ni$ \\ni   条件付き確率 $p(x \\mid y)$ p(x \\mid y)   ドット $x_1,x_2, \\ldots, x_t$ x_1,x_2, \\ldots, x_t   カリグラフィーフォント $\\mathcal L$ \\cal L   太文字ベクトル $\\boldsymbol{w}$ \\boldsymbol{w}    macだと、ギリシャ文字は日本語の読み方で変換するとスペルが出てくるので便利。\n参考：http://easy-copy-mathjax.xxxx7.com/\n追記 $\\KaTeX$だと、カリグラフィーフォントは、$\\mathcal L$:\\mathcal Lこう。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/nlp/nlp-parse-overview-1/",
                "title": "自然言語処理シリーズの構文解析を読む（概要）",
                "section": "posts",
                "date" : "2019-09-24",
                "body": "はじめに 自然言語処理シリーズの構文解析を読んでいきます。\n全体の概要把握:1時間 中身の細かいとこ：3時間 という感じで読み進めて行こうと思います。\n概要 構文解析を用いることで、単語の並びの背後にある文法的な構造を明らかにすることができる。構文解析を学ぶことで、自然言語処理で用いられる様々な先人の知恵を学習できる。\nこの本では以下のような構成となっている。\n 1章、はじめに 2章、品詞タグ付けのための手法と、機械学習の基礎的な事項について 3章、句構造解析について 4章、依存構造解析 5章、文法理論、深い構文解析 6章、構文解析の応用例 7章、構文解析ツールの紹介 8章、モデルやアルゴリズムの学習用・評価用データに用いられるツリーバンクの紹介  以下、各章の概要まとめです。\n2章：品詞解析と機械学習 品詞解析のためのさまざまな技術の解説し、その基盤となる機械学習の考え方と代表的なモデルを紹介する。\n品詞タグ付け：与えられた文章の各単語の品詞を判定し、品詞情報を付与する処理 品詞タガー：品詞タグ付けを行うプログラム ルールベースの手法：shoudの後には動詞がくると決めうちでタグ付けをする手法 素性: 品詞判定の手がかりとして利用する情報\n隠れマルコフモデル 機械学習に基づく品詞タグ付け手法の中で基本的なもの。 単純な計算では、文長に対し計算量が指数関数的に増加する問題がある。\nViterbiアルゴリズム 計算量増加の問題を解決。動的計画法の1種。 アンダーフローの問題がある、この問題に対し、対数をとっても良いが計算が遅くなるというデメリットもある。\n最大エントロピーモデル 最大エントロピーモデルは、品詞判定に役立つ手がかりを素性として利用し予測できるアルゴリズムの一種。品詞の前後のつながりを考慮せずに予測するというモデル。 計算コストは少ないが、素性を柔軟に設計できないため精度が低いという問題点がある。 自然言語処理では、実装が簡単なことからSGDがよく用いられる。学習データの数が多い場合には、短時間で最適化を行うことができる。\n最大エントロピーマルコフモデル 最大エントロピーモデルに、品詞のつながりを考慮させ正確な予測を行うことできるように改良されたモデル。 先行する単語の品詞に関数情報を素性として利用するできるが、最初にタグ付けを間違えると、その誤りによって別の誤りが引き起こされてしまう問題がある。\n条件付き確率場(CRF) 各単語の品詞を個別に予測するのではなく、文全体の品詞列全体を一度に予測しようとするアプローチに基づく代表的な確率モデル。\n構造化パーセプトロン CRFでは、登場する品詞列すべてに対し確率を求めるが、もっとも正解である確率の高い品詞列さえ得られれば良いという状況もある。そのような状況では、構造化パーセプトロンが役にたつ。動的計画法を用いて品詞タグ付けを行う。\nビーム探索 構造化パーセプトロンでは動的計画法を用いて品詞タグ付けを行ったが、素性が局所的な場合には、動的計画法が使えない。そこで、非局所的な様々な素性を利用するためによく用いられるのがビーム探索である。似たような手法として、Max Violationがある。\n生コーパスを利用した学習 これまでの学習は、コーパスを前提にしたものだった。しかしコーパスの構築には膨大な時間がかかる。与えられた文章のみで学習する手法を、半教師あり学習と呼ぶ。\n自己学習 生コーパスを用いる学習に自己学習と呼ばれる方法がある。 これは、CRFや構造化パーセプトロンでは精度向上に効果がないが、隠れマルコフモデルのような生成モデルでは大きな精度向上を得ることができる。これは、生成モデルの場合、EMアルゴリズムの1ステップに対応しているからである。隠れマルコフモデルで自己学習を行う場合、Baum-Welchアルゴリズムを用いる。\n3章：句構造解析 構文解析の表現方法の1つである句構造と、それに基づく構文解析の手法について説明する。\n句構造 文中の句同士の包含関係を階層的にまとめあげることで、その構造を明らかにする。 適切な句構造を得るための問題を2つに分けると、与えられた文に対して文法上可能な全ての句構造を計算することと、それらの中から最も適切な句構造を選択することとなる。\n文脈自由文法 文の句構造を表現するための、最も基本的な文法の一つ。 文脈自由文法のためのボトムアップな構文解析手法の一つであるCKY法と、任意の文脈自由文法を用いてトップダウンに構文解析を行うことが可能なEarly法がある。\n確率文脈自由文法(PCFG) 句構造を列挙した上で、最も確からしい句構造を選択する枠組みの1つ\n確率文脈自由文法(PCFG)の拡張 PCFGを拡張した、Collins Parserの手法について解説 生成的な確率モデルを注意深く設計することで、正しい構文木にたいして大きな確率がわりあてられるようにする。\n識別モデルによる際順位付け 正しい構文木とそうでない構文木を区別する特徴はいくつかあるが、Collins Parserでは限られたものしか考慮することができない。\n評価法 句構造解析の精度の評価には、構文木を構成する句の適合率(precision)と再現率(recall)がよく用いられる。\n4章:依存構造解析 依存構造とは、文中の単語間の関係をグラフで表したものである。\nCKY法 依存構造を句構造だと考え解析する。\nEisner法 同じ出力を得るための解析プロセスが複数存在することを、擬似曖昧性と呼ぶ。 依存構文解析において、擬似曖昧性が生じないようにCKY法を改良したものがEisner法である。\nMST法 これまでの手法は、句構造解析のアルゴリズムを依存構造解析に応用したものであったが、依存構文解析に特有の手法として、最大全域木(MST)法を応用したものが知られている。 最大全域木とは、エッジにスコアが与えられたグラフを入力として、全ノードを被覆する木(=全域木)のうち、スコアのわが最大となるものを求めるアルゴリズムである。\n遷移型依存構造解析 句造像解析と同様のアルゴリズムを依存構造解析でも考えることができる。\n日本語構文解析 p102(スキップ)\n評価法 依存構造解析の評価には、ラベル付きかかり受け精度およびラベルなしかかり受け精度が用いられる。\n5章：文法理論、深い構文解析 3、4章で解説した、句構造・依存構造では明示されない意味的構造をも計算する、構文解析のことを、深い構文解析と呼ぶ。\n組み合わせ範疇文法(CCG) 組み合わせ範疇文法(CCG)とは、各単語にその文法機能を表すカテゴリを与え、そのカテゴリを組み合わせることで文の構造を計算する。\n主辞駆動句構造文法(HPSG) 主辞駆動句構造文法(HPSG)とは、主辞(句の中で意味的もしくは文法的に中心的な役割を果たす語)が持つ文法機能を素性構造というデータ構造で表し、それに基づき文全体の構造を決定する文法理論である。素性構造では、C++の構造体やオブジェクト指向言語におけるクラスに似た形でデータを表す。\n深い構文解析 CCGやHPSGのような文法理論を用いて、CFGより多くの情報をもたせた文法構造を解析する手法を深い文法構造と呼ぶ。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/python/colaboratory-google-drive-mount/",
                "title": "Google ColaboratoryでGoogle driveをマウントする",
                "section": "posts",
                "date" : "2019-09-23",
                "body": "久しぶりにColaboratory使ったらGoogle driveのマウントが簡単になってた。\nbefore 認証\n!apt-get install -y -qq software-properties-common python-software-properties module-init-tools !add-apt-repository -y ppa:alessandro-strada/ppa 2\u0026gt;\u0026amp;1 \u0026gt; /dev/null !apt-get update -qq 2\u0026gt;\u0026amp;1 \u0026gt; /dev/null !apt-get -y install -qq google-drive-ocamlfuse fuse from google.colab import auth auth.authenticate_user() from oauth2client.client import GoogleCredentials creds = GoogleCredentials.get_application_default() import getpass !google-drive-ocamlfuse -headless -id={creds.client_id} -secret={creds.client_secret} \u0026lt; /dev/null 2\u0026gt;\u0026amp;1 | grep URL vcode = getpass.getpass() !echo {vcode} | google-drive-ocamlfuse -headless -id={creds.client_id} -secret={creds.client_secret} マウント\n!mkdir -p drive !google-drive-ocamlfuse drive after from google.colab import drive drive.mount(\u0026#39;/gdrive\u0026#39;) "
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/emacs/emacs-hinamatsuri/",
                "title": "emacsひな祭りいってきたのでためになったpackageなどをまとめておく",
                "section": "posts",
                "date" : "2019-03-08",
                "body": "2019年3月3日に開催された東京Emacsひなまつりにいってきました。\nhttps://tokyo-emacs.connpass.com/event/121603/\n随時コメント追加していきます。\n ox-hugo\nhttps://ox-hugo.scripter.co/\nOx-hugo\nhttps://sfus.net/blog/2018/12/org-mode-with-ox-hugo/\nAtomic-chrome\nhttps://qiita.com/alpha22jp/items/f67bda3ed0c4ac84c29f\nLSP\nhttps://qiita.com/blue0513/items/acc962738c7f4da26656\neglot\nhttps://howm.osdn.jp/index-j.html\nIvy\nhttps://qiita.com/tadsan/items/33ebb8db2271897a462b#ivycounsel\nOrg-chapture\nhttps://www.5ing-myway.com/org-capture/\nchild-frame\nhttps://www.gnu.org/software/emacs/manual/html_node/elisp/Child-Frames.html\nhighlight-indent-guides.el\nhttps://qiita.com/blue0513/items/acc962738c7f4da26656\ndoom-theme\nhttps://github.com/hlissner/emacs-doom-themes\ndoom-modeline\nhttps://github.com/seagle0128/doom-modeline\ngit-gutter\nhttps://emacs-jp.github.io/packages/vcs/git-gutter\nhttps://qiita.com/syohex/items/a669b35fbbfcdda0cbf2\nWhite-space mode\nhttps://qiita.com/itiut@github/items/4d74da2412a29ef59c3a\nProjectile\nhttps://github.com/bbatsov/projectile\nDdss\nhttp://emacs.rubikitch.com/sd1408-ddskk/\nripgrep\nhttps://github.com/dajva/rg.el\nhttp://emacs.rubikitch.com/ripgrep/\n感想 もっとゴリゴリな変態emacs使い(褒め言葉)ばかりかと思ってたけど、実用性の高い話が聞けてよかったです。emacs歴は7,8年ほどですが普段はpythonやmarkdownなどちょっとした開発にemacsを使う程度で、scalaやhtml、jsや規模の大きいプロジェクトなどではIDEを使っています。今回ので良い知見が得られたのでこれからはしっかりemacs使っていこうと思います。 ORGモード人気。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/python/python-get-extn/",
                "title": "pythonで拡張子を取得する",
                "section": "posts",
                "date" : "2019-03-01",
                "body": "ファイルの拡張子を取得する方法をいつも忘れるのでメモ\nimport os file_path = \u0026#34;hoge/test.md\u0026#34; root, ext = os.path.splitext(file_path) print(root, ext) 出力\nhoge/test .md "
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/emacs/lsp-mode/",
                "title": "lsp-modeを導入する",
                "section": "posts",
                "date" : "2018-11-20",
                "body": "大学時代から使っていたemacsの設定たちを綺麗にするという目的で、ついでにlsp-modeを導入してみようと思う。\nlsp-mode\nhttps://github.com/emacs-lsp/lsp-mode\nlanguage server protocolとは language server protocol(lsp)とは、IDEやエディタとIDEが提供する機能(補間、定義jump、ドキュメントの表示など)の間で使用されるプロトコルを定義したものである。\nこれまで、IDEなどの提供する機能(補間、定義へのjump、ドキュメントの表示など)は言語ごと、IDEごとに提供されていた。\nそれを取りまとめるプロトコルが定義されることで、IDEごとの格差が緩和され、emacsでもIDEと同様の機能が実現でき流ようになるということです。\n詳しくは、以下が参考になると思う。\nhttps://microsoft.github.io/language-server-protocol/\nhttps://github.com/Microsoft/language-server-protocol\nhttps://qiita.com/atsushieno/items/ce31df9bd88e98eec5c4\nlsp-mode emacsでは、lsp-modeとeglotがlspをサポートしているみたい。今回はlsp-modeを導入する。\nlsp-mode: https://github.com/emacs-lsp/lsp-mode\nを見ながら設定していく。\nmelpaからインストール\nM-x package-install [RET] lsp-mode [RET] 以下のように設定する。\n(use-package lsp-mode :custom (lsp-print-io t) (lsp-prefer-flymake \u0026#39;flymake) :commands lsp) lsp-print-ioで全てのログを*lsp-log*に表示する。今回はflymakeを使うので、(lsp-prefer-flymake 'flymake) を設定しておく。\n続いて、lsp-modeのバックエンドにcompanyを使うためにcompany-lspを、lsp-modeのUIをリッチにしてくれるlsp-uiを入れる。\nそれぞれmelpaからインストールします。\ncompany-lsp https://github.com/tigersoldier/company-lsp\ncompanyのバックエンドに設定\n(use-package \u0026#39;company-lsp :after (lsp-mode company) :init (push \u0026#39;company-lsp company-backends) ) lsp-ui https://github.com/emacs-lsp/lsp-ui\n(use-package lsp-ui :custom ;; lsp-ui-doc (lsp-ui-doc-enable nil) (lsp-ui-doc-header t) (lsp-ui-doc-include-signature t) (lsp-ui-doc-position \u0026#39;at-point) ;; top, bottom, or at-point (lsp-ui-doc-max-width 150) (lsp-ui-doc-max-height 30) (lsp-ui-doc-use-childframe t) (lsp-ui-doc-use-webkit t) ;; lsp-ui-flycheck (lsp-ui-flycheck-enable nil) ;; lsp-ui-peek (lsp-ui-peek-enable t) (lsp-ui-peek-peek-height 20) (lsp-ui-peek-list-width 50) (lsp-ui-peek-fontify \u0026#39;on-demand) ;; never, on-demand, or always ;; lsp-ui-imenu (lsp-ui-imenu-enable nil) (lsp-ui-imenu-kind-position \u0026#39;top) ;; lsp-ui-sideline (lsp-ui-sideline-enable nil) :commands lsp-ui-mode :config (add-hook \u0026#39;lsp-mode-hook \u0026#39;lsp-ui-mode) (eval-after-load \u0026#34;flymake\u0026#34; (setq flymake-fringe-indicator-position nil) ) ) 主な機能は以下\n lsp-ui-doc:\nリファレンス表示\n(lsp-ui-doc-use-childframe t)でchildframeを使ったドキュメント表示ができる。webkitでもできるみたいだけどうまくいかない lsp-ui-peek:\n定義ジャンプ lsp-ui-sideline\n現在行の情報を表示(肩情報はchildframeで表示され、表示情報が重複しているので非表示にした)  動いている様子は、各GitHubのページで確認\n以上で、lsp-modeの設定は終了\n各言語の設定 goのLanguage Serverはbingoを使うと良いそうです。\nbingo\nhttps://github.com/saibing/bingo\nこれもmelpaでインストールし、以下のように設定\n(use-package go-mode :config (add-hook \u0026#39;go-mode-hook #\u0026#39;lsp) ) まとめ lsp-modeを使って、IDEで提供されている機能をemacsでも使えるように設定しました。これでgo langで補間、リファレンス参照、定義ジャンプなどできるようになりました。その他設定の見直しは今後記事に落としていくということで。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/emacs/emacs-use-package/",
                "title": "use-packagesを使ってみる",
                "section": "posts",
                "date" : "2018-11-20",
                "body": "これまで長い間放置しててきたemacsの設定たちを見直すついでに、use-pacakgeを使ってみようと思う。\nhttps://github.com/jwiegley/use-package\nuse-packageとは、emacsのパッケージ管理を強化するパッケージです。\nuse-packageのマクロを使用することで、\n 統一した記述による可読性が向上 パッケージの遅延ロードの設定を簡潔にかけることによる起動の高速化  などのメリットがあります。\nシンプルな例 requireでのライブラリの読み込みは次のように書き換えることができます。\n(require \u0026#39;foo) (use-package foo) use-packageではキーワードを使うことで、パッケージロード時の振る舞いを指定することができます。\n:init パッケージが読み込まれる前に実行される。\n(use-package foo :init (setq foo-variable t)) :config パッケージがロードされた後に実行される。\n(use-package foo :init (setq foo-variable t) :config (foo-mode 1)) :commands auto-loadするコマンドを指定する。\n(use-package color-moccur :commands (isearch-moccur isearch-all) :bind ((\u0026#34;M-s O\u0026#34; . moccur) :map isearch-mode-map (\u0026#34;M-o\u0026#34; . isearch-moccur) (\u0026#34;M-O\u0026#34; . isearch-moccur-all)) :init (setq isearch-lazy-highlight t) :config (use-package moccur-edit)) この場合、isearch-moccurとisearch-allがcolor-moccur.elからauto-loadされる。\nkey-binding :bindキーワードを使用し以下のように設定する。\n(use-package ace-jump-mode :bind (\u0026#34;C-.\u0026#34; . ace-jump-mode)) リストを使い以下のように複数のキーバインドを設定することも可能\n(use-package hi-lock :bind ((\u0026#34;M-o l\u0026#34; . highlight-lines-matching-regexp) (\u0026#34;M-o r\u0026#34; . highlight-regexp) (\u0026#34;M-o w\u0026#34; . highlight-phrase))) キーバインドは:initと::commandsキーワードを使用し、以下のようにも設定できる。\n(use-package ace-jump-mode :commands ace-jump-mode :init (bind-key \u0026#34;C-.\u0026#34; \u0026#39;ace-jump-mode)) :mode 拡張子とメジャーモードの対応づけはauto-mode-alistで行なっていたが、:modeキーワードを使うことで簡潔に設定できるようになります。\n(use-package python-mode :mode ((\u0026#34;\\\\.py\\\\\u0026#39;\u0026#34;) (\u0026#34;\\\\.pyx\\\\\u0026#39;\u0026#34;)) ) :interpreter シェバンとメジャーモードの対応づけは、:interpreterキーワードを使って設定できます。\n(use-package python-mode :interpreter ((\u0026#34;python\u0026#34; . python-mode) (\u0026#34;python\u0026#34; . python-mode)) :hooks :hookキーワードを使用して、以下のように設定できます。\n(use-package ace-jump-mode :hook prog-mode) (use-package ace-jump-mode :hook (prog-mode . ace-jump-mode)) また、従来のようにadd-hookを用いても設定が可能。\n(use-package ace-jump-mode :commands ace-jump-mode :init (add-hook \u0026#39;prog-mode-hook #\u0026#39;ace-jump-mode)) まとめ use-packageの使い方を簡単にまとめてみました。このくらいあればある程度の設定はできるでしょう。余力があれば加筆します。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/falcon/falcon-img-upload/",
                "title": "falconでアップロードサーバーを作る",
                "section": "posts",
                "date" : "2018-10-16",
                "body": "はじめに 現在、サーバー上にHugoとHugoが生成した静的ファイルを置いてブログを公開している。 静的ファイルの生成とmdファイルや画像ファイルのアップロードのためfalconを使ってapiサーバーを作った。 falconをつかったのは、flaskやbottleは使ったことあったので、使ったことないものをということで。\nクライアント クライアントにはpythonのrequestsを使います。\nfileにタプルでファイル名を明示的に渡せる。 postの引数にfilesで渡すと、contents-typeもよしなにしてくれるんですね。\nimage_name = \u0026#34;test.png\u0026#34; with open(image_file_path, \u0026#34;rb\u0026#34;) as image: files = {\u0026#39;file\u0026#39;: (image_name, image)} response = requests.post(url, files=files) print(response.text) サーバー falconはコンテナ上で動かします。ファイルアップロードのリクエストを受けると、 サーバー上のストレージに画像を保存します。\nなんかできないと思ってたら、middlewareにMultipartMiddlewareを指定しないとだめだった。\nfileは次のようにrequestから取得できる\nimage = req.get_param(\u0026#39;file\u0026#39;) raw = image.file.read() ファイル名は次のように取得\nimage_name = image.filename 実際は、corsとかあるがそれを省いた、アップロードだけの全体は以下のようになる。\nfrom falcon_multipart.middleware import MultipartMiddleware import falcon import json class UploadImage(object): def on_post(self, req, resp): image = req.get_param(\u0026#39;file\u0026#39;) raw = image.file.read() image_name = image.filename filepath = os.path.join(BASE_DIR, \u0026#34;static\u0026#34;, image_name) try: with open(filepath, \u0026#39;wb\u0026#39;) as f: f.write(raw) except IOError: print(\u0026#34;save file faild :\u0026#34; + filepath) resp.body = to_resp(200, \u0026#34;save img \u0026#34; + filepath) def to_resp(status_code, contents): resp = { \u0026#34;status\u0026#34;: status_code, \u0026#34;contents\u0026#34;: contents } return json.dumps(resp) app = falcon.API(middleware=[MultipartMiddleware()]) app.add_route(\u0026#34;/image\u0026#34;, UploadImage()) if __name__ == \u0026#34;__main__\u0026#34;: from wsgiref import simple_server httpd = simple_server.make_server(\u0026#34;0.0.0.0\u0026#34;, 8000, app) httpd.serve_forever() "
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/falcon/falcon-tips/",
                "title": "falconを使ってみた",
                "section": "posts",
                "date" : "2018-10-16",
                "body": "はじめに Hugoをおいているwebサーバーに画像や、mdファイルをアップロードするためのapiサーバーとしてfalconを使ってみた。ORMなど必要なく、簡単なアップロードができれば良いということで、軽量さとシンプルさが特徴のfalconを使う。\n簡単なtipsをメモしておく。\nシンプルな例 falconの公式に乗っているように、シンプルな例は次のようになる。\n# sample.py import falcon class QuoteResource: def on_get(self, req, resp): \u0026#34;\u0026#34;\u0026#34;Handles GET requests\u0026#34;\u0026#34;\u0026#34; quote = { \u0026#39;quote\u0026#39;: ( \u0026#34;I\u0026#39;ve always been more interested in \u0026#34; \u0026#34;the future than in the past.\u0026#34; ), \u0026#39;author\u0026#39;: \u0026#39;Grace Hopper\u0026#39; } resp.media = quote api = falcon.API() api.add_route(\u0026#39;/quote\u0026#39;, QuoteResource()) 処理シーケンス falconにはmiddlewareの他に、hooksというものが使える。 hooksを含めた処理シーケンスは次のようになる。\nMiddleware's process_request Middleware's process_resource Hook's before Resource's on_**** Hook's after Middleware's process_response 引用：https://qiita.com/yohjizzz/items/f46bb3bc7b7c40768836\nmiddlewareを使った、認証系の共通処理はよく見るが、hookが使えるのは良いですね。\nhooks hooksは以下のように使う。(公式)\ndef validate_image_type(req, resp, resource, params): .... @falcon.before(validate_image_type) def on_post(self, req, resp): pass 処理を差し込みたいメソッドにでコレーターでつけるだけ。\nmiddleware corsくらいしか使わなかったが、dbのconnection poolとかに使うようのものとかあるんだろう。(公式)\nclass CORSMiddleware: def process_request(self, req, resp): resp.set_header(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;) エラーハンドリング routeが見つからなかった時に、エラーリスポンスを返したいときは以下のようにする。(公式)\nclass Index(object): def on_get(self, req, resp): resp.body = json.dumps({\u0026#34;message\u0026#34;:\u0026#34;ok\u0026#34;}) app = falcon.API() app.add_route(\u0026#34;/\u0026#34;, Index()) app.add_sink(handle_404, \u0026#39;\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: from wsgiref import simple_server httpd = simple_server.make_server(\u0026#34;127.0.0.7\u0026#34;, 8000, app) httpd.serve_forever() exceptionなどが起きた場合でも、200のリスポンスを返し、レスポンスボディの中でエラーコードとメッセージを返したかったが、うまく行かなかったので、これは次の機会にやる。\nrequestの取得 requsetの取得は以下のようになる。(公式)\nclass HealthCheck(object): def on_get(self, req, resp): print(req.headers) # headerの取得 print(req.params[\u0026#39;name\u0026#39;]) # request paramの取得 # request bodyの取得 body = req.stream.read().decode(\u0026#34;utf-8\u0026#34;) data = json.loads(body) name = data[\u0026#39;name\u0026#39;] app = falcon.API() app.add_route(\u0026#34;/\u0026#34;, index()) if __name__ == \u0026#34;__main__\u0026#34;: from wsgiref import simple_server httpd = simple_server.make_server(\u0026#34;127.0.0.7\u0026#34;, 8000, app) httpd.serve_forever() "
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/hugo/hugo-start-article/",
                "title": "Hugoでブログを作る",
                "section": "posts",
                "date" : "2018-10-16",
                "body": "はじめに Hugoとは、go言語で書かれた、静的なwebサイトをbuildingするためのframeworkです。 Hugoを使ってブログを作ってみたので構築方法を簡単にまとめておきます。\nサイトの作成 インストール brew install hugo テンプレートの作成 hugo new site hugo-test これで、次のようにテンプレートが作成されます。\n$ ls hugo-test/ archetypes/ config.toml content/ data/ layouts/ static/ themes/ テーマの適応 https://themes.gohugo.io/ ここからテーマを探す。\n例として、https://themes.gohugo.io/hugo-theme-learn/ を使います。\n$ cd hugo-test/themes $ git clone https://github.com/matcornic/hugo-theme-learn.git テーマを適応させるために、config.tomlにthemeを記述します。\ntheme = \u0026quot;hugo-theme-learn\u0026quot; サーバーの起動 $ hugo server -D -t hugo-theme-learn オプションDでDraftフラグのついた記事の確認、オプションtでテーマの適応です。 cloneしてきたtheme内の、layoutとstaticなどを、作成したテンプレート内のlayout、staticに移動しておくと、templateのマイナーチェンジが行えます。\nデフォルトでhttp://localhost:1313/で起動するのでアクセスしてみる。\n記事の追加 記事の作成\n$ hugo new post/test.md hugo_test/content/post/test.md created 以下のようなmarkdownファイルが作成される\ncat content/post/test.md --- title: \u0026quot;Test\u0026quot; date: 2018-10-15T18:51:47+09:00 draft: false --- ここで、draftは記事を後悔するかのフラグ この出力フォーマットも、独自に設定が可能\n$ hugo server --watch watchフラグをつけると、mdファイルが更新されるたびに、web側に更新が反映される。 markdownの記事を書きながら、フォーマットを確認するのに使えそう。\nデプロイ 以下のコマンドで実際にpublic以下にstaticファイルが吐き出される\n$ hugo -t hugo-theme-learn $ ls public/ 404.html categories css fonts images index.html index.xml js mermaid sitemap.xml tags webfonts このpublicディレクトリをwebサーバーに与えるだけでおk。\nまとめ Hugoのインストールからデプロイまでをまとめました。 html内で使える変数や、数式、画像の表示はまた別でまとめます。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/hugo/hugo-href-to-target-blank/",
                "title": "Hugoでリンクを新しいウィンドウで開く",
                "section": "posts",
                "date" : "2018-10-16",
                "body": "リンクは新しいウィンドウで開いて欲しい派なんだけど、Hugoではデフォルトで通常のリンクの開きかた(?)をする。\nhrefではtarget='_blank'を指定すれば良いのだが、markdownでどうすれば良いのか調べた。 Hugoでは次のようにconfig.tomlするといける。\n[blackfriday] hrefTargetBlank = true 簡単！\n参考：\n https://gohugo.io/getting-started/configuration/ https://www.meganii.com/blog/2017/02/25/hugo-markdown-href-target-blank/  "
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/hugo/hugo-ga/",
                "title": "Hugoにgoogle analyticsを導入する",
                "section": "posts",
                "date" : "2018-10-16",
                "body": "Hugoにgoogle analytics(ga)を導入しようと思ったら意外と簡単だった。\nまず、gaアカウントを作成。\nconfig.tomlに\ngoogleAnalytics = \u0026quot;{ga tracking ID}\u0026quot; を設定するだけ。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/hugo/hugo-long-time-no-see/",
                "title": "Hugoのディレクトリ構造やデプロイ方法の備忘録",
                "section": "posts",
                "date" : "2018-10-16",
                "body": "久しぶりにHugoを触ったら、ディレクトリ構造からデプロイ方法までさっぱり忘れていたので、久しぶりに触った際のために備忘録を残す。\nディレクトリ 基本的なディレクトリは以下\nmarkdownを書いたりと普段触るのはcontentディレクトリになる。\nデプロイ後生成されるpublicディレクトリはサーバーなどで公開する。\narchetypes/ ・・・ markdown記事を生成する際のテンプレートなど config.toml ・・・ 設定ファイル content/ ・・・　markdownの記事を配置 layouts/　・・・ Htmlの共通部分 public/ ・・・ デプロイ後に生成される静的ファイル群 static/ ・・・ cssなどの静的ファイルを配置 themes/ ・・・ テーマを配置 デプロイ hugoのプロジェクトルートで以下のコマンドを打つ\n$ hugo -t ./ 記事を書くときには以下のコマンドを使う。\n$ hugo server -t ./ localにサーバーが立ち上がり、markdownを書きながら生成される記事を確認できる。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/hugo/hugo-code-highlight/",
                "title": "Hugoの記事でコードハイライトする",
                "section": "posts",
                "date" : "2018-10-16",
                "body": "Hugoでコードのシンタックスハイライトする場合のメモ\nHugo自体の機能を使う方法と、ハイライトする機能を持つjavascriptを読み込む2つの方法がある。\nHugo自体の機能使う Hugo 0.28からGo機能でシンタックスハイライトが可能になった。\nSyntax Highlighting\nconfig.tomlに以下のように記述\npygmentsCodefences = true pygmentsUseClasses = true 以下のコマンドでcssを生成する。\n$hugo gen chromastyles --style=monokai \u0026gt; syntax.css 生成したcssをindex.htmlなどから読み込むと反映される。\n--styleオプションの指定は、pygmentsから探す。\nhighlightjsを使う highlightjs\n対応言語が多いのがメリット。\n以下のようにcdnからとってくるようにしておくと良い。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;hljs.initHighlightingOnLoad();\u0026lt;/script\u0026gt; 一行目の記述を以下のように書き換えることでテーマを選択できる。\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/zenburn.min.css\u0026#34;\u0026gt; "
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/hugo/hugo-add-site-description/",
                "title": "Hugoの記事にdescriptionを追加する",
                "section": "posts",
                "date" : "2018-10-16",
                "body": "Hugoで書いた記事が検索で引っかからないなと思っていたら、descriptionタグが設定されていませんでした。 これでは検索に引っかからないのでdescriptionタグをつけましょう!\nhtml側で次のように書くと、markdownに書いたdescriptionが参照できます。\n{{ .Description }} markdown側では、ヘッダーに次のように記述します。\ndescription=\u0026quot;hogehoge\u0026quot; これまで書いた記事全てに、descriptionをつけていくのは面倒ですね。\n次のようにサイトサマリーを参照することも可能です\n{{ .Summary }} ただし、デフォルトでサマリーが大きくなりすぎるので、config.tomlに次のような記述を追加します。\nhasCJKLanguage = true こうすることでサマリーがいい感じのサイズになります。\n参考：https://blog.awm.jp/2016/01/02/hugo/\n最終的に、header.htmlなどに次のように記述しておけば、descriptionを書いておくとそちらが使われるようになります。\n{{ if .Description }} \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;{{ .Description }}\u0026#34;\u0026gt; {{ else }} \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;{{ .Summary }}\u0026#34;\u0026gt; {{ end }} サイトのディスクリプションと記事のディスクリプションを分ける(追記) {{ if .IsHome }}でトップページかどうか判定できるので、トップページならば、configのディスクリプションを使い、記事内ならば記事に設定してあるディスクリプションを使う。\nhtml側は次のように記述する。\n{{ if .IsHome }} {{ with .Site.Params.description }} \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;{{ . }}\u0026#34;\u0026gt; {{ end }} {{ end }} {{ if .Description }} \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;{{ .Description }}\u0026#34;\u0026gt; {{ else }} \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;{{ .Summary }}\u0026#34;\u0026gt; {{ end }} configに次のように記述する。\n[params] description=\u0026#34;hogehoge\u0026#34; configで任意の変数を指定するのは、paramsの中じゃないとだめなので注意。 参考：https://gohugo.io/getting-started/configuration/\n他のもっとスマートな方法があれば教えてください。\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/hugo/hugo-on-image/",
                "title": "Hugoの記事に画像を載せる",
                "section": "posts",
                "date" : "2018-10-16",
                "body": "Hugoに画像を載せるときは、shortcodesを使うと良いらしい。\n画像を配置するディクトリを以下のように作っておく。\n{root}/content/post/images/ 以下のように記述すると表示できる。\n{{\u0026lt; figure src=\u0026quot;../../images/test.png\u0026quot; title=\u0026quot;test\u0026quot; width=\u0026quot;320\u0026quot; height=\u0026quot;640\u0026quot; \u0026gt;}} or\n[!tag](path) 相対パスで記述でき、width、heightも設定可能。\n生成されるHTMLは以下のようになる。\n\u0026lt;figure\u0026gt; \u0026lt;img src=\u0026quot;../../images/test.png\u0026quot; /\u0026gt; \u0026lt;figcaption\u0026gt; \u0026lt;h4\u0026gt;test\u0026lt;/h4\u0026gt; \u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; 画像を実際に表示\n 記事と同じディレクトリに画像を配置しておくと、シンプルなパスで記述できるので、その辺は好みで。\n画像が多くなりすぎるとgitで管理したくないので、クラウドストレージとかに移行するとかしないとな\u0026hellip;\n"
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/hugo/hugo-date-sort/",
                "title": "Hugoの記事を更新順にソートする",
                "section": "posts",
                "date" : "2018-10-16",
                "body": "Hugoの記事を更新順にソートするメモです。\nまず、Hugoの記事に更新時刻情報を付与します。markdownのヘッダーにdate情報を書いても良いのですが、gitで管理している場合には、Lastmodで更新時刻が取得できるのでそれを使います。\nそのほかにもgitから情報が取得できます。https://gohugo.io/variables/git/\nconfig.tomlに以下のように記述します。\nenableGitInfo=true 以下のように使う。\n{{ .Lastmod.Format \u0026quot;2006/01/02\u0026quot; }} この更新事項を使って、記事を並び替えます。\n記事のリストを表示するhtmlはもともと以下のように記述してありました。\n{{ $paginator := .Paginate (where .Data.Pages \u0026quot;Type\u0026quot; \u0026quot;post\u0026quot;) 10 }} {{ range $paginator.Pages }} 以下のリンクを参考にします。\nhttps://gohugo.io/templates/lists/\nlastmod以外にも並び替えが行えます。\n結局、以下のように記述しました。\n{{ $paginator := .Paginate (where .Data.Pages \u0026quot;Type\u0026quot; \u0026quot;post\u0026quot;).ByLastmod.Reverse 10 }} {{ range $paginator.Pages }} "
            }
        
    ,
        
            {
                "ref": "https://www.if-blog.site/posts/hugo/hugo-git-pages/",
                "title": "HugoをGitHub Pagesで公開する",
                "section": "posts",
                "date" : "2018-10-16",
                "body": "GitHub Pagesを使ってHugoを公開する手順をメモ\nやりたいこととしては、\n Hugoのプロジェクトを丸ごとgitで管理 プロジェクトの下に作られるpublicをGitHub Pagesで公開 独自ドメインの設定  の3つです。\nGitHub Pagesで公開 まずは、Hugoのプロジェクトルートをgitで管理します。\nGitHub Pagesで公開するために、GitHubのリポジトリの設定からPagesで公開するための設定を行います。このとき、そのまま公開すると、Hugoをビルドして生成されるファイルはプロジェクトルート直下のpublic以下に生成されるので、\nhttps://{ユーザー名}.github.io/{リポジトリ名}/{public} というように、URLにpublicが付いてしまいます。これは嫌なので、git subtreeを使います。\ngh-pagesという新しいブランチを作成し、public以下のファイルのみをpushしています。github pagesではgh-pagesを公開するよう設定します。\n$ git subtree push --prefix public/ . gh-pages $ git push origin gh-pages:gh-pages GitHubから独自ドメインの設定をすると、ブランチgh-pagesにCNAMEファイルが追加、commitされるのですが、この変更をローカルのmasterに取り込めないという問題が発生しました。このため、ローカルで記事を追加したときなど、non-fast-forwardでpush、pullもできなくなりました。そこで、しょうがなくmaster側にローカルからCNAMEファイルを追加しました。\nそれでもうまくいかないときは、エラー文のcommitのハッシュを使って無理やりpushしてとりあえず回避してます。\n例\n$ git subtree push --prefix public/ . gh-pages git push using: . gh-pages To . 59 (58) ! [rejected] 95625bda7b4247ff0d05b2e76c8db1cbb7e87dad -\u0026gt; gh-pages (non-fast-forward) error: failed to push some refs to \u0026#39;.\u0026#39; hint: Updates were rejected because a pushed branch tip is behind its remote hint: counterpart. Check out this branch and integrate the remote changes hint: (e.g. \u0026#39;git pull ...\u0026#39;) before pushing again. hint: See the \u0026#39;Note about fast-forwards\u0026#39; in \u0026#39;git push --help\u0026#39; for details. $ git push origin 95625bda7b4247ff0d05b2e76c8db1cbb7e87dad:gh-pages 独自ドメインの設定 今回は、お名前.comでドメインを取得しました。お名前.comでDNSの設定をします。\nGitHub Pagesのドメインは\nhttps://{ユーザー名}.github.io/{リポジトリ名} なので、取得したドメインでGitHub PagesのドメインがひけるようにCNAMEの設定を行います。\nGitHub側では、リポジトリの設定からCustom domainを取得したドメインで設定します。Custom domainを設定すると、Enforce HTTPSにチェックを入れることができるので、設定するとhttpsで通信が行えるようになります。\n"
            }
        
    
]
